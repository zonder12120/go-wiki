---
order: 5
title: Map, хэш-таблицы
---

Это ещё более сложная структура данных, чем слайсы, так что приготовься морально к долгому чтиву.

## Если просто

Мапа в Go ялвляется реализацией хэш-таблиц в ЯП Go.

Хэш-таблица обеспечивает:

-  быстрый доступ к данным за константное время O(1)

-  эффективное использование памяти

-  универсальность (хранение различных типов данных как в качестве ключа, так и значения)

Мапа в Go по сути похожа на слайс, где каждый его элемент из себя представляет пару ключ-значение. То есть итерируясь по мапе, мы будем получать ключ и значение по этому ключу.

Схематично можно представить мапу так:

```
[{key0, value0}, {key1, value1}, … {keyN, valueN}]
```

Создаём мы мапу, объявляя типы для ключа и значения (то есть типы могут быть любыми допустимыми, но фиксированными для одной мапы) + возможна инициализация

### Типы данных для ключей:

-  **Все числовые типы** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128)

-  **Строки** (string)

-  **Булевы значения** (bool)

-  **Указатели** (\*T)

-  **Интерфейсы** (interface{})

-  **Структуры** (если все поля структуры могут быть сравнены с помощью `==`)

-  **Массивы** (если элементы массива могут быть сравнены с помощью `==`)

### Не могут быть использованы в качестве ключей:

-  **Срезы** (slice)

-  **Карты** (map)

-  **Функции** (func)

Ключи карты должны быть сравниваемыми типами данных, т.е.  которые можно сравнивать с помощью оператора `==`. Это необходимо для обеспечения корректности операций добавления, удаления и поиска элементов в карте.

### Типы данных для значений map:

Значения в карте могут быть любого типа, включая:

-  **Все числовые типы** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128)

-  **Строки** (string)

-  **Булевы значения** (bool)

-  **Указатели** (\*T)

-  **Интерфейсы** (interface{})

-  **Структуры** (struct)

-  **Массивы** (array)

-  **Срезы** (slice)

-  **Карты** (map)

-  **Функции** (func)

-  **Каналы** (chan)

-  **Интерфейсы** (interface{})

### Объявление мапы

```
m := map[string]int {      // Объявление с инициализацией
	"Один": 1,
	"Два": 2,
	"Три": 3,              // Обращаю внимание на висящую запятую, без неё синтаксическая ошибка
} 

m := make(map[string]int)      // Объявление пустой мапы, при выводе будет: map[]

m := make(map[string]int, 10)  // Пустая мапа с заданой ёмкостью для оптимизации аллокации памяти

var m map[string]int           // Не инициализированная мапа со значение nil

var m map[string]int{}         // Вызовет синтаксическую ошибку 
// так как объявление с инициализацией требует указания значний как в первом примере
```

После объявления мапы давайте с ней поработаем

### Работа с мапой

#### Итерация по мапе:

```
m := map[string]int {
	"Один": 1,
	"Два": 2,
	"Три": 3,
} 

for key, value := range(m) {
	fmt.Println(ket, value)
}
```

#### Добавление или обновление элемента:

```
m["Четыре»] = 4
```

#### Удаление элемента:

```
delete(m, "четыре")
```

#### Получение значения по ключу:

```
value := m["три»] // 3
```

#### Проверка наличия ключа в мапе:

```
value, ok := m["три"] // 3, true

value, ok = m["пять"] // 3, false
```

## Если посложнее

### Хэш-функция

Но как мапа позволяет иметь такой быстрый доступ к данным, итерируясь не по индексу, а по ключу? Допустим, у нас в качестве ключа указана строка, поиск по такому ключу будет происходить дольше, чем по индексу.

Всё верно, но поиск по мапе и производится как раз по индексу. **Всё дело в хэш-функции**

Когда вы добавляете или ищете элемент по ключу (например, строке), хэш-функция преобразует этот ключ в хэш-значение. Полученное хэш-значение делится по модулю на размер массива, чтобы получить индекс, в который будет помещен элемент.



## Если совсем сложно

Подробное строение мапы нужно только таким же больным любопытным ублюдкам вроде меня, а для большинства задач хватит понимания того, что метод оптимизации работы с мапой такой же, как и со слайсом - заранее аллоцируем память, если мапа может активно расти. Хотя, если обращение к мапе не будет таким частым, то внутренних оптимизаций мапы хватит и не обязательно выделять заранее конкретное число элементов.

Но вот всё же немного приоткроем капот, чтобы понять, как там шестерёнки двигаются:

Структура map:

{% table %}

---

*  {% colwidth=[90] %}

   **Header**

---

*  {% colwidth=[90] %}

   **Bucket**

{% /table %}

То есть сама мапа состоит из 2 структур под названием header и bucket