---
order: 1
title: Языки программирования
---

## Компилятор и/или интерпретатор

Языки программирования  являются абстракцией над машинными кодом. Современные высокоуровневые языки программирования отдалены от работы с регистрами, адресами памяти и стеками вызовов, вместо этого они предоставляют более удобные конструкции для работы, такие как переменные, массивы, объекты и другие абстракции.

Низкоуровневые языки программирования, такие как язык ассемблера, требуют разработки отдельного кода под каждую конкретную архитектуру процессора. Это обусловлено тем, что инструкции ассемблера и набор регистров различаются в зависимости от архитектуры процессора, что делает разработку дольше и дороже, поэтому сейчас модно писать на языках с другими подходами.

:::info 

Если что, не Fortran стал первым высокоуровневым ЯП, как многие считают, а Планкалкюль, созданный немецким инженером Конрадом Цузе в 1943–1945 годах и впервые опубликованный в 1948 году. Если интересно, есть статейка про него на Хабре: <https://habr.com/ru/articles/133887/>

:::

Современные ЯП позволяют писать привычные нам ключевые слова, как например `fmt.Println(“Hello, World”)` , но дело в том, что **железо наше понимает именно машинный код** (нули и единицы), а не эти вот буковки всякие.

В машинный код ЯП преобразуется при помощи **трансляторов кода**: **компилятора** и/или **интерпретатора**

### Компилятор

Компилятор преобразует (транслирует) весь исходный код программы в машинный код (под определённую платформу) до выполнения. Полученный машинный код затем может быть выполнен непосредственно аппаратным обеспечением (процессором).

#### Преимущества:

1. **Высокая производительность**:

   -  Поскольку код компилируется заранее, он исполняется быстрее, чем интерпретируемый код.

2. **Отсутствие необходимости в среде выполнения**:

   -  Скомпилированный код можно выполнять без наличия дополнительных интерпретаторов или виртуальных машин.

3. **Оптимизации**:

   -  Компиляторы могут проводить различные оптимизации на этапе компиляции, что улучшает производительность и уменьшает размер кода.

#### Недостатки:

1. **Отсутствие гибкости**:

   Для каждой целевой платформы необходима отдельная компиляция. Это может добавить сложности при разработке для нескольких платформ.

2. **Длительное время компиляции**:

   Компиляция может занимать значительное время, особенно для больших проектов.

:::info 

**Почему нужно компилировать под каждую платформу?**

Каждая операционная система предоставляет свой набор системных вызовов, библиотек и интерфейсов для работы с ресурсами устройства, файлами, сетью и другими компонентами. Код на Go, использующий эти API, должен быть скомпилирован специально под каждую ОС, чтобы обеспечить корректное взаимодействие с ней.

Если не понятно, почему под каждую архитектуру процессоров отдельно комплируется код, почитай подробнее в интернете, это не заканчивается просто различием набора инструкций архитектур, есть ещё оптимизации, безопасность и т.д.

:::

### Интерпретатор

Интерпретатор преобразует и исполняет код по одной инструкции за раз. Это означает, что каждая инструкция сначала переводится в машинный код, а затем сразу же выполняется.

#### Преимущества:

1. **Гибкость и портируемость**:

   Интерпретируемый код может выполняться на любой платформе, где доступен интерпретатор, без необходимости перекомпиляции.

2. **Простота отладки**:

   Интерпретаторы позволяют выполнять и проверять код по шагам, что упрощает отладку и тестирование.

3. **Быстрый запуск**:

   Программы могут быть запущены сразу без длительного этапа компиляции.

#### Недостатки:

1. **Низкая производительность**:

   Интерпретируемый код выполняется медленнее, чем скомпилированный, так как каждая инструкция должна быть сначала переведена в машинный код.

2. **Наличие среды выполнения**:

   Для выполнения кода требуется наличие интерпретатора, что добавляет зависимость и может увеличить размер исполняемого окружения.

### **Пример на языках Go и Java:**

**1) Go** копилируется сразу в машинный код, поэтому его нужно отдельно компилировать под каждую ОС и архитектуру процессора.

Для кросс-компиляции программы Go под другую ОС и архитектуру можно использовать переменные окружения `GOOS` и `GOARCH`. Например, чтобы скомпилировать программу для Linux на архитектуре ARM:

```Bash
SET GOOS=linux
SET GOARCH=arm
go build -o myprogram
```

**2)** В **Java** это работает иначе, сначала код на Java компилируется в байт-код, промежуточный код, который **не зависит от платформы** и можем исполниться любой JVM (виртуальной машиной Java).

А вот реализация JVM **зависит от платформы**.

После компиляции в байт-код, JVM читает байт-код и выполняет его инструкции одну за другой. Интерпретатор преобразует байт-код в соответствующие машинные инструкции, которые могут быть выполнены процессором.

Для повышения производительности JVM может использовать JIT-компилятор:

-  **JIT-компиляция**: Часто выполняемые части байт-кода компилируются в машинный код во время выполнения программы. Это позволяет ускорить выполнение, так как машинный код исполняется быстрее, чем интерпретируемый байт-код.

-  **Оптимизации**: JIT-компилятор может применять различные оптимизации для улучшения производительности, такие как инлайнинг методов, устранение мертвого кода и т.д.

Обоснован такой сложный подход тем, что байт-код Java остается одинаковым независимо от платформы, благодаря чему программы Java могут быть написаны один раз и выполнены на любой платформе, для которой существует JVM.

### Послесловие

Вообще процесс превращения кода на определённом языке в машинный код включает в себя много разных процессов, которые на начальном этапе можно и опустить, потому что куда важнее нам для начала создать фундамент, а не углубляться в процесс.

### Моё (особо важное) мнение

Лично мне нравится классический подход Go. По крайней мере для современной веб-разработки лично я не вижу проблем скомпилировать код для определённого сервака.

А на Java все равно придётся ставить свой JRE для каждой платформы, что не сильно то и упрощает процесс.

Go предлагает простой и прямолинейный процесс разработки и развёртывания, люблю такое <3

Холивар я не развожу, это просто моё мнение, в программировании всё-таки куда больше философии, чем чистой инженерии, иначе бы и не было бы столько холиваров, все бы пользовались одним лучшим решением и всё.