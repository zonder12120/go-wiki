---
order: 4
title: "Операционные системы\_(доделать)"
---

## Прелюдия

Если ты не потрогал сам лично  Linux, крайне рекомендую получить такой незабываемый опыт осознания разницы философий винды и линуха, хотя бы уже просто на уровне user experience, когда от стадии непринятия терминала ты доходишь до стадии презрения к виндовому powershell. Для этого просто посиди недельку другую на линухе как на основной системе.

Ну и как факт, знания линукса сейчас требуется во многих вакансиях, так как ты будешь разрабатывать с вероятностью 99% сервисы именно под линуксоидные серваки.

Именно поэтому в этой статье **я буду больше опираться на работу Linux.**

## Что такое ОС

ОС по сути является **прослойкой между железом и софтом**. Она выполняет множество критически важных функций, обеспечивая взаимодействие между программами и аппаратными ресурсами компьютера. Такой вот менеджер ресурсов

## Функции ОС

Давай так, функций операционок предостаточно, но их все перечислять сейчас особого смысла нет, по крайней мере для старта в Гошке. Иначе копать вглубь можно бесконечно долго, операционные системы - это целая наука. На этом я буду основывать на протяжении всей статьи. Слишком глубоко копать не буду.

Хочешь углубиться в тему – погружайся в гугл, но аккуратно выбирай источники, не стоит читать первую попавшуюся статью на Хабре. Сейчас модно поливать помоями Википедию, но я бы сперва пошёл туда.

Разберём те функции, которые для нас сейчас наиболее важны для общего понимания роли ОС.

### 1\. **Управление памятью и процессами**

-  **Загрузка программ и управление памятью**: ОС загружает программы в память, распределяет память между процессами, организует виртуальную память.

-  **Исполнение запросов программ**: Обработка ввода/вывода (input/output - i/o), запуск и остановка программ, управление памятью.

### 2\. **Распределение ресурсов, многозадачность и многопоточность**

-  **Распределение ресурсов**: Эффективное распределение процессорного времени и других ресурсов между процессами.

-  **Многозадачность**: Обеспечение параллельного выполнения задач путём переключения между процессами.

-  **Многопоточность**: Поддержка выполнения нескольких потоков внутри одного процесса, что позволяет выполнять несколько задач параллельно в рамках одного приложения.

### 3\. **Безопасность и взаимодействие**

-  **Защита системы и данных**: Обеспечение безопасности системы и данных от злонамеренных действий или ошибок.

-  **Взаимодействие между процессами**: Обмен данными и синхронизация между процессами.

### 4\. **Управление данными и устройствами**

-  **Файловая система**: Управление доступом к данным на дисках.

-  **Работа с устройствами**: Стандартизованный доступ к периферийным устройствам через унифицированные интерфейсы.

## Ядро

Ядро (kernel) является центральной частью операционной системы, управляющей аппаратным обеспечением и обеспечивающей взаимодействие между программным обеспечением и аппаратурой. В Linux, как и в других операционных системах, ядро выполняет множество критических функций, и его работа критична для функционирования всей системы. Давайте рассмотрим его подробнее.

### Определение и задачи ядра

**Ядро** -- это привилегированная часть операционной системы, которая работает в режиме ядра (kernel mode) и имеет полный доступ к аппаратным ресурсам компьютера и является постоянно загруженной в ОЗУ.

Оно управляет аппаратным обеспечением и предоставляет интерфейсы (system calls) для пользовательских приложений, работающих в пользовательском режиме (user mode).

### Архитектура ядра Linux

Ядро Linux имеет модульную архитектуру, что означает, что оно состоит из различных компонентов, которые могут быть загружены и выгружены по мере необходимости.

Основные компоненты ядра Linux:

1. **Основное ядро (core kernel)**:

   -  **Процессорное управление**: Управляет процессами и потоками.

   -  **Управление памятью**: Отвечает за распределение и управление памятью.

   -  **Системные вызовы**: Предоставляет интерфейсы для взаимодействия с пользовательскими приложениями.

2. **Модули ядра (kernel modules)**:

   -  **Драйверы устройств**: Модули, которые обеспечивают поддержку различных аппаратных устройств.

   -  **Файловые системы**: Модули для поддержки различных файловых систем (например, ext4, XFS).

   -  **Сетевые протоколы**: Модули для поддержки различных сетевых протоколов.

3. **Системные вызовы (system calls)**:

   -  **Интерфейс для пользовательских приложений**: Предоставляет функции, которые приложения могут вызывать для выполнения операций, требующих привилегий ядра (например, доступ к файлам, создание процессов).

4. **Диспетчер прерываний (interrupt handler)**:

   -  **Обработка аппаратных прерываний**: Обрабатывает прерывания от аппаратного оборудования и запускает соответствующие обработчики.

5. **Менеджер процессов (process manager)**:

   -  **Управление процессами**: Отвечает за создание, завершение и планирование процессов.

## Как работает программа в ОС? Процессы и потоки

:::tip:true Доп литература для психов: 

1. Роберт Лав - Ядро Linux, описание процесса разработки

2. Илюшкин Б.И. Операционные системы. Процессы и потоки - Учебное пособие

:::

### Режимы выполнения

Ты помнишь, что программы исполняются процессором, верно? Будь то какие-либо системные процессы или пользовательские приложения. И было бы не правильно раздавать им одинаковые права на доступ к аппаратному обеспечению твоего ПК. Поэтому у современных процессоров есть 2 режима работы, эти режимы обеспечиваются операционной системой: 

-  **Пользовательский режим (User Mode)**: В этом режиме выполняются обычные приложения. В пользовательском режиме доступ к аппаратным ресурсам у ЦП ограничен, чтобы предотвратить случайные или злонамеренные действия, которые могли бы нарушить работу системы.

-  **Режим ядра (Kernel Mode)**: В этом режиме работает ядро операционной системы и драйверы устройств. В режиме ядра процессор может выполнять любые команды и обращаться к любым ресурсам системы.

### Процесс

Когда вы запускаете программу, операционная система создаёт новый процесс для её выполнения.

**Процесс** -- это **не** экземпляр исполняемой программы. 

  

**Процесс** можно воспринимать, для упрощения, своего рода **контейнером**, внутри которого есть все необходимые ресурсы для выполнения программы. Это включает в себя сам программный код, индивидуальное адресное пространство памяти, дескрипторы файлов, переменные окружения и другие ресурсы, необходимые для исполнения этого кода. То есть это не просто программа, потому что программа - это просто инструкция. **Процесс** – это **совокупность** разных ресурсов.

Программа выполняется в одном или нескольких процессах, а процессы могут содержать потоки, где каждый поток отвечает за выполнение отдельных задач. Причём программист сам  управляет разделением программы на процессы и потоки. 

![](./operating-systems.png)

:::info:true Структура процесса

1. **Идентификатор процесса (PID)**:

   -  Уникальный номер, который идентифицирует процесс в системе. Каждый процесс имеет свой PID, присваиваемый ему при создании.

2. **Память процесса**:

   -  **Текстовый сегмент (Text Segment)**: Содержит исполняемый код программы.

   -  **Сегмент данных (Data Segment)**: Включает статические переменные и глобальные данные.

   -  **Сегмент BSS (Block Started by Symbol)**: Содержит неинициализированные глобальные и статические переменные.

   -  **Куча (Heap)**: Динамическая память, используемая для выделения памяти во время выполнения программы.

   -  **Виртуальная память**: Адресное пространство процесса, отображаемое на физическую память через таблицы страниц. Про неё ниже.

3. **Состояние процесса (Task State Segment, TSS)**:

   -  Содержит информацию о текущем состоянии процесса, включая регистры процессора, указатель инструкции, указатель стека и флаги состояния.

4. **Приоритет процесса**:

   -  **Приоритеты**: В Linux процессы имеют динамические и статические приоритеты. Статический приоритет определяет базовое время выполнения процесса, а динамический может изменяться во время выполнения процесса в зависимости от его поведения и использования ресурсов.

   -  **Nice-значение**: Значение, которое может быть установлено для регулирования приоритета процесса. Чем выше значение nice, тем ниже приоритет процесса, и наоборот.

5. **Таблица дескрипторов файлов**:

   -  Содержит ссылки на все открытые файлы, сокеты и устройства, которые использует процесс. Эта таблица позволяет процессу взаимодействовать с файловой системой и другими внешними ресурсами.

6. **Таблица страниц (Page Table)**:

   -  Маппинг между виртуальными и физическими адресами. В Linux каждая таблица страниц организована иерархически (например, с использованием четырёхуровневой страничной таблицы на x86_64).

7. **Контрольный блок процесса (Process Control Block, PCB)**:

   -  Структура данных, которая хранит всю информацию, необходимую для управления процессом. В Linux она представлена структурой `task_struct`.

8. **Таймеры и сигналы**:

   -  **Сигналы**: Механизм асинхронного уведомления процесса о различных событиях (например, завершение программы, сигнал от другого процесса). Сигналы могут быть отправлены процессу для выполнения определённых действий, таких как завершение или остановка.

   -  **Таймеры**: Процессы могут устанавливать таймеры для выполнения определённых действий через заданное время.

9. **Процессорное время (CPU time)**:

   -  **Время в режиме пользователя (User Time)**: Время, которое процесс провёл, выполняя пользовательский код.

   -  **Время в режиме ядра (Kernel Time)**: Время, которое процесс провёл, выполняя системные вызовы или код ядра.

10. **Родственные связи**:

    -  Процессы в Linux организованы в иерархию, где каждый процесс имеет родителя и, возможно, дочерние процессы. Эта информация сохраняется в `task_struct` и позволяет системе отслеживать группы процессов.

11. **Окружение (Environment)**:

    -  Включает переменные окружения, которые процесс использует для выполнения задач. Это может включать путь к исполняемым файлам, настройки локали и другие параметры.

12. **Политика планирования (Scheduling Policy)**:

    -  **Round-robin (RR)**, **First-Come, First-Served (FCFS)**, **Completely Fair Scheduler (CFS)** и другие алгоритмы, используемые для определения порядка выполнения процессов.

:::

**Дочерние процессы** - это процессы, созданные на основе другого процесса. Процесс создания нового процесса на основе другого называется **форкингом (forking),** работает через системные вызов `fork()`.

Кстати, `fork()` – это единственный способ создать новый процесс в системе Linux. На самом деле в Linux создаётся два процесса не через `fork()` при инициализации системы `kthreadd` и `systemd`

`kthreadd` -- это специальный процесс, который управляет созданием и управлением ядровыми потоками (kernel threads) в Linux.

`systemd` (ранее **init**) -- это первый процесс, который запускается ядром после завершения его инициализации. Он имеет идентификатор процесса (PID) 1. Этот процесс отвечает за запуск и управление остальными процессами в системе.

Когда новый процесс создается, он наследует множество характеристик от своего родительского процесса, являясь по сути его точной копией за исключением **PID** + у дочернего процесса появляется **PPID** (Parent Process ID). Есть ещё некоторые различия, но сейчас нам это не так важно.

После `fork()`, потомок может заменить свое содержимое другим программным кодом, вызывая `exec()`.

Системный вызов `exec()` загружает в память новый исполняемый файл и начинает его выполнение, заменяя собой исходный процесс.

После `exec()` процесс **перестает быть копией родителя** и начинает выполнение новой программы, сохраняя прежний PID и большинство атрибутов процесса, **оставаясь доченим процессом**.

Когда потомок завершает свою работу, он не исчезает сразу. Его запись в таблице процессов сохраняется, чтобы родительский процесс мог узнать статус завершения потомка. Такой процесс называется **зомби-процессом**.

Родитель должен вызвать `wait()` или `waitpid()`, чтобы получить информацию о завершении потомка и освободить запись о нем в таблице процессов. **После этого зомби-процесс удаляется.**

Если родительский процесс **завершится раньше дочернего**, дочерний процесс становится **сиротой**. В этом случае система переназначает дочерний процесс на процесс `systemd`, который берет на себя ответственность за «усыновление» и управление завершением этого процесса.

После этого **сирота продолжает свою работу** без какой-либо зависимости от своего исходного родителя.

Процесс-сирота продолжает своё исполнение в обычном режиме, как и любой другой процесс, пока не завершит свои задачи или не будет явно остановлен.

Каждый процесс **изолирован от других процессов**, что позволяет защитить память и ресурсы одного процесса от вмешательства со стороны другого. При этом есть механизмы “общения” между процессами.

**Процессы могут взаимодействовать** через механизмы межпроцессного взаимодействия, такие как shared memory, message queues, pipes, и sockets.

**Shared memory** -- наиболее быстрый способ взаимодействия, так как процессы могут разделять одну и ту же область памяти.

Процессы могут открывать **сетевые сокеты** для связи с другими процессами или серверами через сеть. Как и файловые дескрипторы, сетевые сокеты являются ресурсами, которыми управляет процесс.

Процессы могут использовать разные модели ввода-вывода (например, синхронный, асинхронный или неблокирующий I/O) для работы с сетевыми сокетами.

### Поток

**Поток** в контексте операционной системы -- это независимая последовательность выполнения инструкций внутри процесса. Потоки позволяют процессу выполнять несколько задач параллельно, используя одно и то же окружение.

В Linux потоки (threads) выглядят для системы как отдельные процессы, но с определенными особенностями, которые отличают их от классических дочерних процессов.

Поток -- это единица выполнения, которая получает время процессора для выполнения инструкций. Без хотя бы одного потока процесс просто не может выполнять какие-либо действия. То есть **процесс без потока не может существовать**. Именно потоки выполняют работу.

Внутри процесса есть минимум один поток, который является **основным**. 

Основной поток создается автоматически при создании процесса, и именно он начинает выполнение программы.

Основной поток выполняет код процесса, и он может создавать дополнительные потоки (в многопоточных приложениях) для параллельного выполнения задач.

Процесс в целом завершается, когда завершает свою работу основной поток или все потоки процесса завершены (если основной поток завершил работу, а остальные потоки продолжают работать, процесс может продолжать существовать до завершения последнего потока).

:::info:true Структура потока в Linux:

1. **Идентификатор потока (Thread ID)**:

   -  Уникальный идентификатор потока в рамках процесса, например, PID (Process ID) для потока в ядре Linux.

2. **Регистры процессора**:

   -  **Указатель инструкции (Program Counter, PC)**: Указывает на текущую инструкцию, которая выполняется.

   -  **Регистры общего назначения**: Хранят промежуточные данные и результаты вычислений.

   -  **Указатель стека (Stack Pointer, SP)**: Указывает на вершину стека потока, необходим для управления стеком.

3. **Стек (Stack)**:

   -  Отдельный стек для каждого потока, где хранятся локальные переменные, параметры функций и адреса возврата. Стек потока независим от стека других потоков.

4. **Состояние потока**:

   -  Определяет текущее состояние потока: **RUNNING** (выполняется), **READY** (готов к выполнению), **WAITING** (ожидает события), **TERMINATED** (завершён).

5. **Приоритет потока**:

   -  Определяет, насколько важен поток относительно других потоков. Это может включать **статический приоритет** и **динамический приоритет**, изменяющийся в зависимости от поведения потока.

6. **Контекст потока**:

   -  Включает в себя регистры процессора и указатель стека, а также другую информацию, необходимую для возобновления выполнения потока после его приостановки.

7. **Ресурсы потока**:

   -  **Файловые дескрипторы**: Дескрипторы открытых файлов и других ресурсов, доступных потоку.

   -  **Синхронизация и примитивы**: Механизмы для управления доступом к общим ресурсам и синхронизации между потоками, такие как мьютексы, семафоры и условные переменные.

8. **Данные потока**:

   -  **Потоковые данные**: Локальные переменные и данные, которые используются конкретным потоком в процессе выполнения.



:::

Потоки внутри одного процесса делят общее адресное пространство памяти. Это означает, что они могут совместно использовать данные в куче и глобальные переменные, что делает межпоточное взаимодействие более эффективным, но требует осторожности для избежания состояния гонки и других проблем синхронизации.

Каждый поток имеет собственные стек и регистры, но разделяет кучу процесса с другими потоками.

Все потоки с одним PID будут видны как один процесс с множеством потоков, если просмотреть их с помощью команд, таких как `ps` или `top`.

:::tip:true Если упростить

**Процесс - это контейнер**, который хранит в себе общие ресурсы (например кучу) для потоков + является обобщающей и изолирующей оболочкой для потоков (со своей виртуальной памятью), таким образом ОС общается не с отдельно взятыми потоками, а с целым процессом. При этом процесс сам по себе не выполняет работу, для этого у него есть как минимум **основной поток**, создающийся при запуске процесса, который уже может порождать дочерние потоки для многопоточных операций.

**Именно основной поток является по сути истансом запущенной программы.** В потоках уже есть свои отдельные ресурсы для работы, которые они не делят с другими потокам (например стек и регистры), но также они могут использовать общие ресурсы своего процесса.

Процессы тоже могут порождать дочерние процессы, создавая свои полные копии с возможностью загрузки туда другого кода для своих нужд.

:::

**Одновременно процессором может исполняться не больше потоков ОС, чем доступных потоков процессора (логических ядер)!**

Но ведь у нас постоянно запущено в ОС огромное количество процессов, как тогда они все исоплняются на компьютере, да ещё и одновременно? Тут влетает с двух ног планировщик.

### Так как понять разницу между процессом и потоком?

Часто люди используют эти слова как синонимы, и иногда это даже уместно. Но технически поток не является "экземпляром» программы, он больше ассоциируется с выполнением конкретной части кода в рамках одного процесса.

### Пример:

-  Запусти текстовый редактор (например, `vim`). Оська создаёт процесс для этого редактора. Этот процесс имеет своё собственное адресное пространство, файловые дескрипторы, и ресурсы.

-  Внутри этого процесса могут быть запущены несколько потоков. Например, один поток может отвечать за обработку пользовательского ввода, другой -- за отображение текста на экране, третий -- за сохранение изменений в файл.

Процесс -- это экземпляр программы, который выполняется в изолированном пространстве, тогда как потоки -- это единицы выполнения внутри одного процесса, которые могут работать параллельно и совместно использовать ресурсы процесса.

## Планировщик и многопоточность

**Планировщик ОС выбирает**, какие потоки будут исполняться в данный момент на процессоре, а какие будут ожидать своей очереди. Этот выбор происходит на основе различных алгоритмов планирования (про них на начальном этапе не вижу смысла рассказывать), при этом поток может не выполниться до конца и уступить своё место другому потоку.

Когда планировщик решает, что поток должен уступить место другому потоку, он сохраняет состояние текущего потока (контекст) и загружает контекст нового потока. **Это называется переключением контекста.**

Планировщик ОС обеспечивает иллюзию параллельного выполнения множества потоков, за счёт быстрого переключения между потоками.

Потоки могут использовать примитивы синхронизации, такие как мьютексы, семафоры и другие механизмы, чтобы координировать доступ к разделяемым ресурсам.

Мьютексы и семафоры являются частью системы управления процессами и потоками в ОС. В большинстве современных операционных систем, таких как Linux и Windows, эти механизмы реализованы на уровне ядра.

Про примитивы синхронизации потоков мы поговорим отдельно, так как потом это поможет чуть глубже понять многопоточность в Go.

Без грамонтного использования примитивов синхронизации может возникнуть **состояние гонки.**

**Race condition (состояние гонки)** - это ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации. Представить можно в формате очереди, один за одним.

Вот наглядное объяснение сосояния гонки, не смотря на индусский английский, смотрится легко, да и материал простенько представлен, парень молодец.

[video:https://www.youtube.com/watch?v=7aF0q7NfwfA:]

**Если коротко пересказать видево, то вот суть:**

-  Переменная `X` изначально равна 10.

-  Поток 1 и Поток 2 начинают выполнение почти одновременно.

-  Оба потока исполняют функцию `x += 10`

**Возможное состояние гонки**:

-  Поток 1 читает значение `X`, которое равно 10.

-  Поток 2 также читает значение `X`, которое еще равно 10.

-  Оба потока выполняют функцию `x += 10`, то есть каждый поток считает, что `X` равно 10, и прибавляет к нему 10.

-  Оба потока записывают результат обратно в `X`, что приводит к значению `X = 20` для обоих потоков.

Итог: хотя по логике ты ожидал, что `X` станет 30, оно остается 20, потому что оба потока одновременно обновили переменную на основе устаревшего значения.

**Использование примитивов синхронизации**:

-  Если Поток 1, который запустился раньше, использует **мьютекс (про него расскажу ниже)** для блокировки доступа к выполнению функции, то он завершит свою операцию полностью (чтение, добавление и запись нового значения) перед тем, как Поток 2 получит доступ к `X`.

-  Поток 1 читает `X = 10`, добавляет 10, и записывает результат `X = 20`.

-  Только после этого Поток 2 может начать выполнение, при этом он прочитает уже обновленное значение `X = 20`, добавит к нему 10, и запишет результат `X = 30`.

Итог: С помощью примитивов синхронизации результат будет таким, каким и ожидался -- `X` станет 30.

### Семафор

**Семафо́р** –  примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик.

Довольно забавное название, такая метафора на потоки и железную дорогу.

Семафор содержит целое число, которое называется счётчиком. Это число отражает количество доступных ресурсов или разрешений.

Планировщик использует очереди готовности, где находятся процессы и потоки, ожидающие своей очереди на выполнение.

`wait` (или `down` или `P`\-операция): Операция, которая **уменьшает** значение счётчика на единицу. Если значение счётчика положительное, поток или процесс получает доступ к ресурсу и продолжает работу. Если счётчик равен нулю, поток или процесс блокируется и ждёт, пока ресурс не станет доступным (счётчик увеличится)

`signal` (или `up` или `V`\-операция): Операция, которая **увеличивает** значение счётчика на единицу. Если какой-то поток или процесс был заблокирован на операции `wait`, он будет разблокирован и сможет продолжить работу.

:::info:true Пример использования семафора:

Представь себе систему с пулом из трех соединений к базе данных. Чтобы предотвратить использование большего количества соединений, чем доступно, можно использовать семафор с начальным значением 3. Каждый раз, когда поток хочет получить соединение, он выполняет операцию `wait`. Если все три соединения заняты, поток будет ждать. Когда поток освобождает соединение, он выполняет `signal`, увеличивая значение семафора, что позволяет другому потоку получить доступ к освободившемуся соединению.

:::

Не смотря на метафору с железной дорогой, я воспринимаю семафор как секьюрити, который следит, чтобы в помещении было ровно обозначенное количество людей одновременно и пропускает остальных только тогда, когда уходит другой и освобождается место. \**Ковидные флешбэки\*.*

### Мьютекс

**Мьютекс** (от англ. *mutex*, сокращение от *mutual exclusion* -- "взаимное исключение") -- это примитив синхронизации, используемый в многопоточных и многопроцессорных системах для предотвращения одновременного доступа нескольких потоков или процессов к общему ресурсу. Основная задача мьютекса -- обеспечить, чтобы только один поток или процесс мог выполнять критическую секцию кода в любой момент времени, тем самым предотвращая состояния гонки и некорректное поведение программы.

Мьютексы **не блокируют** **использование** какой-то конкретной **области памяти напрямую**. Вместо этого они **блокируют выполнение кода**, который работает с этой памятью или ресурсами. Когда поток захватывает мьютекс (с помощью `mu.Lock()`), он получает право на выполнение критической секции. Другие потоки, которые пытаются захватить этот же мьютекс, будут заблокированы и вынуждены ждать, пока мьютекс не будет освобождён (с помощью `mu.Unlock()`).

**Мьютекс предоставляет две основные операции:**

-  `Lock()`: Эта операция захватывает мьютекс. Если мьютекс уже захвачен другим потоком, текущий поток будет заблокирован до тех пор, пока мьютекс не освободится.

-  `Unlock()`: Эта операция освобождает мьютекс, позволяя другим заблокированным потокам попытаться захватить его.

Пример использования мьютекса я привёл выше, пересказывая ролик с объяснением работы состояния гонки.

## Виртуальная память

:::tip 

На эту тему есть замечательное видео <https://www.youtube.com/watch?v=x4FQ6ASzkso&t=353s>

:::

ОС должна **выделить и** **изолировать память для каждого процесса**, как в целях безопасности данных, так и для оптимизации выделения памяти для процессов. Для решения многих вопросов работы  памяти был придуман механизм **виртуальной памяти**. Как это работает?

### **Основная идея виртуальной памяти**

Программы обращаются к памяти через виртуальные адреса. Виртуальное адресное пространство -- это логическая модель памяти, которую программа видит как непрерывный и однородный блок. Хотя это совсем не так.

Процессы  не «видят» физическую память напрямую и не знают, где физически хранятся данные -- в ОЗУ или в файле подкачки.

Виртуальная память делится на блоки фиксированного размера, называемые **страницами**. Размер страницы обычно составляет 4 КБ, хотя возможны и другие размеры в зависимости от архитектуры процессора и конфигурации операционной системы (например, 2 МБ или 1 ГБ).

Физическая память также делится на блоки того же размера, называемые **фреймами** (frames). Каждая страница виртуальной памяти может быть загружена в любой фрейм физической памяти.

Фреймы выделяются для страниц по разным алгоритмам, но так или иначе, страницы идут последовательно друг за другом, то есть сначала страница под номером 1, затем страница под номером 2 и так далее, но вот страница 1 может соответствовать фрейму под номером 8 а страница 2 может соответствовать фрейму под номером 5.

То есть по факту у нас в ОЗУ беспорядочно хранятся куски данных разных процессов.

Для процесса, однако, всё выглядит как последовательное пространство, потому что он работает с виртуальной памятью, а не с физическими адресами.

![](./operating-systems-3.png)

### Зачем так перемешивать фреймы?

Непоследовательное распределение фреймов позволяет ОС эффективно использовать физическую память, избегая фрагментации и недоиспользования ресурсов.

ОС может динамически выделять и освобождать память для процессов, не привязываясь к строгой последовательности фреймов.

Когда процессу требуется память, он обращается к операционной системе с запросом на выделение необходимого объёма виртуальной памяти, в процессе заполнения страниц, им присваиваются фреймы, куда и идёт запись.

### Как сопоставляются страницы и фреймы?

Для управления соответствием между виртуальными адресами (страницами) и физическими адресами (фреймами) используется **таблица страниц (page table)**. Каждому процессу соответствует своя таблица страниц, которая содержит информацию о том, где находятся соответствующие страницы в физической памяти.

При обращении программы к виртуальному адресу процессор с помощью **MMU** **(Memory Management Unit)** переводит этот адрес в физический с использованием таблицы страниц.

При запросе определённых данных, например значения переменной, передаётся не только номер страницы, ведь страница – это тоже область памяти, нас же интересуют конкретные байты. Поэтому передаётся ещё **смещение (offset)**, на котором относительно начала этой области памяти находятся нужные нам данные.

После того как физический фрейм найден, MMU добавляет offset из виртуального адреса к началу физического фрейма, чтобы получить **точный физический адрес конкретных данных.**

![](./operating-systems-2.png)

### **Подкачка (paging)**

Когда оперативной памяти не хватает, операционная система начинает использовать **файл подкачки (swap)**, перенося туда редко используемые страницы памяти из ОЗУ. Файл подкачки располагается системой на постоянных носителях по типу SSD или HDD. Выгруженные в файл подкачки страницы возвращаются в оперативную память, когда это необходимо ИЛИ в процессе prefetching’а. Это позволяет запускать программы, которые требуют больше памяти, чем доступно физически.

То есть логическое адресное пространство программы может быть больше, чем физически есть памяти в ОЗУ, как раз таки за счёт того, что не вся память используется программой единовременно и некоторые блоки могут быть перемещены на вторичный накопитель в файл подачки.

Если процесс пытается получить доступ к странице, которая не загружена в физическую память (например, была выгружена на диск), возникает **page fault** (исключение отказа страницы), и ОС загружает страницу обратно в ОЗУ. Процесс, который запросил доступ к отсутствующей странице, **временно приостанавливается**. Как только страница загружена в ОЗУ из вторичного накопителя и таблица страниц обновлена, **процесс возобновляет свою работу с того места, на котором остановился**, теперь уже с доступом к необходимым данным. Такой процесс, когда подгружаются страницы из swap при прямой необходимости называется **demand paging (подкачка по запросу или ленивая подкачка).**

### Prefetching

**Prefetching** **(предварительная подкачка)** из swap -- это процесс, при котором операционная система загружает страницы памяти из файла подкачки  обратно в оперативную память до того, как они понадобятся процессу. Это позволяет уменьшить задержки и повысить производительность, так как страницы могут быть уже в памяти, когда процесс захочет их использовать.

В Linux prefetching  происходит автоматически, управляется ядром операционной системы и связан с механизмами управления виртуальной памятью.

#### Как ОС понимает, что надо заранее подгрузить страницы?

Для принятия решения о том, какие страницы стоит заранее подгрузить, система использует несколько ключевых подходов:

1. **Анализ доступа к страницам**:

   Linux использует алгоритмы управления памятью, которые анализируют последние обращения к страницам. Если страница недавно была выгружена в swap, но процесс снова начал активно её использовать, то система может сделать вывод, что есть высокая вероятность повторного использования этой страницы и заранее подгружает её обратно в оперативную память.

2. **Swap readahead**:

   Когда процесс обращается к странице, находящейся в swap, и эта страница подгружается в оперативную память, Linux может также подгружать соседние страницы, предполагая, что они также могут скоро понадобиться процессу. Это особенно полезно для процессов, которые работают с последовательными блоками данных. В Linux существует параметр **page-cluster**, который определяет количество соседних страниц, подгружаемых вместе с запрашиваемой страницей.

3. **Swappiness**:

   Параметр swappiness в Linux регулирует агрессивность использования swap. Значение swappiness влияет на то, как часто ОС будет выгружать страницы в swap и как быстро она будет подгружать их обратно. Чем выше значение swappiness, тем чаще ОС будет использовать swap и тем быстрее она будет пытаться загружать страницы из swap обратно в память. Однако стоит отметить, что swappiness не влияет напрямую на prefetching, но косвенно может изменять поведение системы при работе со swap.

4. **Предсказание на основе предыдущей активности**:

   Linux может также использовать исторические данные о поведении процесса для предсказания будущих обращений к страницам памяти. Например, если процесс циклически обращается к определённым страницам, ОС может предугадать эти обращения и заранее подгрузить страницы из swap. Этот механизм является частью общего подхода к управлению памятью.

5. **Оценка свободной памяти**:

   Если в системе достаточно свободной оперативной памяти, ОС может быть более агрессивной в подгрузке страниц из swap, чтобы минимизировать потенциальные задержки при обращении к ним. Это делается для повышения производительности за счёт использования неактивных ресурсов. В противоположном случае, при недостатке памяти, система может менее агрессивно подгружать страницы из swap, чтобы избежать вытеснения недавно загруженных данных.

## Системные вызовы

### Что это такое?

Так как программа напрямую не может общаться с железом, а посредником между ними является ОС (конкретно ядро), тогда для общения между ними должна быть **api**.

Команды такого api ОС называется **системными вызовами.**

**POSIX** (Portable Operating System Interface) -- это стандарт, разработанный для обеспечения совместимости и портируемости операционных систем и программного обеспечения. Этот стандарт определяет набор интерфейсов и API, которые операционные системы должны поддерживать для обеспечения совместимости приложений и инструментов, работающих на различных платформах.

POSIX предназначен для обеспечения того, чтобы программы, написанные для одной операционной системы, могли быть перенесены и работать на другой операционной системе, которая поддерживает POSIX.

Linux и Mac OS частично поддерживают POSIX с некоторыми своими различиями и расширениями

### Как используются системные вызовы?

Вот как приложение использует системные вызовы и взаимодействует с ядром операционной системы:

1. Когда приложение запускается, оно начинает выполняться в **пользовательском режиме** (user mode). В этом режиме приложение имеет **ограниченный доступ** к аппаратным ресурсам и не может напрямую управлять ими.

2. Когда приложению требуется доступ к системным ресурсам, таким как файлы, сеть, память и т.д., оно использует **системные вызовы** (system calls). Системные вызовы - это специальные функции, предоставляемые ядром ОС, которые позволяют приложениям взаимодействовать с ядром.

3. Для выполнения системного вызова, приложение генерирует специальный прерывание (interrupt), которое переключает процессор в режим ядра (kernel mode). В этом режиме ядро ОС имеет полный доступ к аппаратным ресурсам и может выполнять запрошенную операцию.

4. Ядро ОС распознает системный вызов по специальному идентификатору, который передается приложением. Ядро проверяет, что этот вызов является допустимым для данного приложения, и выполняет соответствующую операцию.

5. После завершения операции, ядро возвращает управление обратно в пользовательский режим, передавая результат выполнения системного вызова приложению.

### Основные системные вызовы

#### **Работа с файлами**:

-  `open()`: Открывает файл и возвращает файловый дескриптор, который можно использовать для последующих операций.

-  `read()`: Читает данные из файла, указанных файловым дескриптором, в буфер.

-  `write()`: Записывает данные из буфера в файл.

-  `close()`: Закрывает файловый дескриптор, освобождая все ресурсы, связанные с файлом.

#### **Управление процессами**:

-  `fork()`: Создает новый процесс (дочерний процесс), который является копией текущего процесса (родительского).

-  `exec()`: Замещает текущий процесс новым процессом (запускает другую программу). В чистом виде вызова `exec()` не существует. Это семейство вызовов (`execl()`, `execp()`, `execle()` и т.д.) позволяет выполнить новый исполняемый файл. 

-  `wait()`: Ожидает завершения дочернего процесса и получает его статус завершения.

-  `exit()`: Завершает выполнение текущего процесса и передает код завершения обратно в родительский процесс.

#### **Работа с сетью**:

-  `socket()`: Создает новый сетевой сокет.

-  `bind()`: Привязывает сокет к адресу (например, IP-адресу и порту).

-  `listen()`: Ожидает входящие соединения на сокете.

-  `accept()`: Принимает входящее соединение на сокете.

-  `send()`: Отправляет данные через сокет.

-  `recv()`: Принимает данные через сокет.

-  `close()`: Закрывает сетевой сокет.