---
order: 4
title: "Операционные системы\_(доделать)"
---

## Прелюдия

Думаю, про ОС особо много прелюдий не надо. Если ты не потрогал сам лично  Linux, крайне рекомендую получить такой незабываемый опыт осознания разницы философий винды и линуха, хотя бы уже просто на уровне user experience, когда от стадии непринятия терминала ты доходишь до стадии презрения к виндовому powershell. Для этого просто посиди недельку на линухе как на основной системе. 

Ну и как факт, знания линукса сейчас требуется во многих вакансиях, так как ты будешь разрабатывать с вероятностью 99% сервисы именно под линуксоидные серваки. 

Именно поэтому в этой статье **я буду больше опираться на работу Linux.**

## Что такое ОС

ОС по сути является **прослойкой между железом и софтом**. Она выполняет множество критически важных функций, обеспечивая взаимодействие между программами и аппаратными ресурсами компьютера. Такой вот менеджер ресурсов

## Функции ОС

Давай так, функций операционок предостаточно, но их все перечислять сейчас особого смысла нет, по крайней мере для старта в Гошке. Иначе копать вглубь можно бесконечно долго, операционные системы - это целая наука.

Хочешь углубиться в тему – погружайся в гугл, но аккуратно выбирай источники, не стоит читать первую попавшуюся статью на Хабре. Сейчас модно поливать помоями Википедию, но я бы сперва пошёл туда.

Разберём те функции, которые для нас сейчас наиболее важны для общего понимания роли ОС.

### 1\. **Управление памятью и процессами**

-  **Загрузка программ и управление памятью**: ОС загружает программы в память, распределяет память между процессами, организует виртуальную память.

-  **Исполнение запросов программ**: Обработка ввода/вывода (input/output - i/o), запуск и остановка программ, управление памятью.

### 2\. **Распределение ресурсов, многозадачность и многопоточность**

-  **Распределение ресурсов**: Эффективное распределение процессорного времени и других ресурсов между процессами.

-  **Многозадачность**: Обеспечение параллельного выполнения задач путём переключения между процессами.

-  **Многопоточность**: Поддержка выполнения нескольких потоков внутри одного процесса, что позволяет выполнять несколько задач параллельно в рамках одного приложения.

### 3\. **Безопасность и взаимодействие**

-  **Защита системы и данных**: Обеспечение безопасности системы и данных от злонамеренных действий или ошибок.

-  **Взаимодействие между процессами**: Обмен данными и синхронизация между процессами.

### 4\. **Управление данными и устройствами**

-  **Файловая система**: Управление доступом к данным на дисках.

-  **Работа с устройствами**: Стандартизованный доступ к периферийным устройствам через унифицированные интерфейсы.

## Как работает программа в ОС?

:::tip:true Доп литература для психов: 

1. Роберт Лав - Ядро Linux, описание процесса разработки

2. Илюшкин Б.И. Операционные системы. Процессы и потоки - Учебное пособие

:::

**Программа** -- это довольно большой набор инструкций, который для эффективного выполнения может быть декомпозирован программистом.

**Процесс** представляет собой экземпляр выполняемой программы.

:::info:true Cтруктура процесса в Linux:

1. **Идентификатор процесса (PID)**:

   -  Уникальный номер, который идентифицирует процесс в системе. Каждый процесс имеет свой PID, присваиваемый ему при создании.

2. **Память процесса**:

   -  **Текстовый сегмент (Text Segment)**: Содержит исполняемый код программы.

   -  **Сегмент данных (Data Segment)**: Включает статические переменные и глобальные данные.

   -  **Сегмент BSS (Block Started by Symbol)**: Содержит неинициализированные глобальные и статические переменные.

   -  **Куча (Heap)**: Динамическая память, используемая для выделения памяти во время выполнения программы.

   -  **Стек (Stack)**: Используется для хранения локальных переменных, параметров функций и адресов возврата.

   -  **Виртуальная память**: Адресное пространство процесса, отображаемое на физическую память через таблицы страниц. Про неё ниже.

3. **Состояние процесса (Task State Segment, TSS)**:

   -  Содержит информацию о текущем состоянии процесса, включая регистры процессора, указатель инструкции, указатель стека и флаги состояния.

4. **Приоритет процесса**:

   -  **Приоритеты**: В Linux процессы имеют динамические и статические приоритеты. Статический приоритет определяет базовое время выполнения процесса, а динамический может изменяться во время выполнения процесса в зависимости от его поведения и использования ресурсов.

   -  **Nice-значение**: Значение, которое может быть установлено для регулирования приоритета процесса. Чем выше значение nice, тем ниже приоритет процесса, и наоборот.

5. **Таблица дескрипторов файлов**:

   -  Содержит ссылки на все открытые файлы, сокеты и устройства, которые использует процесс. Эта таблица позволяет процессу взаимодействовать с файловой системой и другими внешними ресурсами.

6. **Таблица страниц (Page Table)**:

   -  Маппинг между виртуальными и физическими адресами. В Linux каждая таблица страниц организована иерархически (например, с использованием четырёхуровневой страничной таблицы на x86_64).

7. **Контрольный блок процесса (Process Control Block, PCB)**:

   -  Структура данных, которая хранит всю информацию, необходимую для управления процессом. В Linux она представлена структурой `task_struct`.

8. **Таймеры и сигналы**:

   -  **Сигналы**: Механизм асинхронного уведомления процесса о различных событиях (например, завершение программы, сигнал от другого процесса). Сигналы могут быть отправлены процессу для выполнения определённых действий, таких как завершение или остановка.

   -  **Таймеры**: Процессы могут устанавливать таймеры для выполнения определённых действий через заданное время.

9. **Процессорное время (CPU time)**:

   -  **Время в режиме пользователя (User Time)**: Время, которое процесс провёл, выполняя пользовательский код.

   -  **Время в режиме ядра (Kernel Time)**: Время, которое процесс провёл, выполняя системные вызовы или код ядра.

10. **Родственные связи**:

    -  Процессы в Linux организованы в иерархию, где каждый процесс имеет родителя и, возможно, дочерние процессы. Эта информация сохраняется в `task_struct` и позволяет системе отслеживать группы процессов.

11. **Окружение (Environment)**:

    -  Включает переменные окружения, которые процесс использует для выполнения задач. Это может включать путь к исполняемым файлам, настройки локали и другие параметры.

12. **Политика планирования (Scheduling Policy)**:

    -  **Round-robin (RR)**, **First-Come, First-Served (FCFS)**, **Completely Fair Scheduler (CFS)** и другие алгоритмы, используемые для определения порядка выполнения процессов.

:::

Программа выполняется в одном или нескольких процессах, а процессы могут содержать потоки, где каждый поток отвечает за выполнение отдельных задач. Причём программист сам  управляет разделением программы на процессы и потоки.

![](./operating-systems.png)

**Процесс** можно воспринимать своего рода контейнером, внутри которого есть все необходимые ресурсы для выполнения программы. Это включает в себя индивидуальное адресное пространство памяти, дескрипторы файлов, переменные окружения и другие ресурсы.

**Элементы процесса:**

-  адресное пространство

-  потоки

-  открытые файлы

-  дочерние процессы

Каждый процесс изолирован от других процессов, что позволяет защитить память и ресурсы одного процесса от вмешательства со стороны другого. При этом есть возможность использовать одну и ту же область памяти разными процессами, если есть такая необходимость.

**Поток** в контексте операционной системы -- это независимая последовательность выполнения инструкций внутри процесса. Поток разделяет ресурсы (такие как память, дескрипторы файлов и т.д.) с другими потоками того же процесса. Потоки позволяют процессу выполнять несколько задач параллельно, используя одно и то же окружение.

:::info:true Структура потока в Linux:

1. **Идентификатор потока (Thread ID)**:

   -  Уникальный идентификатор потока в рамках процесса, например, PID (Process ID) для потока в ядре Linux.

2. **Регистры процессора**:

   -  **Указатель инструкции (Program Counter, PC)**: Указывает на текущую инструкцию, которая выполняется.

   -  **Регистры общего назначения**: Хранят промежуточные данные и результаты вычислений.

   -  **Указатель стека (Stack Pointer, SP)**: Указывает на вершину стека потока, необходим для управления стеком.

3. **Стек (Stack)**:

   -  Отдельный стек для каждого потока, где хранятся локальные переменные, параметры функций и адреса возврата. Стек потока независим от стека других потоков.

4. **Состояние потока**:

   -  Определяет текущее состояние потока: **RUNNING** (выполняется), **READY** (готов к выполнению), **WAITING** (ожидает события), **TERMINATED** (завершён).

5. **Приоритет потока**:

   -  Определяет, насколько важен поток относительно других потоков. Это может включать **статический приоритет** и **динамический приоритет**, изменяющийся в зависимости от поведения потока.

6. **Контекст потока**:

   -  Включает в себя регистры процессора и указатель стека, а также другую информацию, необходимую для возобновления выполнения потока после его приостановки.

7. **Ресурсы потока**:

   -  **Файловые дескрипторы**: Дескрипторы открытых файлов и других ресурсов, доступных потоку.

   -  **Синхронизация и примитивы**: Механизмы для управления доступом к общим ресурсам и синхронизации между потоками, такие как мьютексы, семафоры и условные переменные.

8. **Данные потока**:

   -  **Потоковые данные**: Локальные переменные и данные, которые используются конкретным потоком в процессе выполнения.

:::

**Одновременно процессором может исполняться не больше потоков ОС, чем доступных потоков процессора (логических ядер)!**

Но ведь у нас постоянно запущено в ОС огромное количество процессов, как тогда они все исоплняются на компьютере, да ещё и одновременно? Тут влетает с двух ног планировщик.

## Планировщик и многопоточность

**Планировщик ОС выбирает**, какие потоки будут исполняться в данный момент на процессоре, а какие будут ожидать своей очереди. Этот выбор происходит на основе различных алгоритмов планирования, при этом поток может не выполниться до конца и уступить своё место другому потоку.

Когда планировщик решает, что поток должен уступить место другому потоку, он сохраняет состояние текущего потока (контекст) и загружает контекст нового потока. **Это называется переключением контекста.**

Потоки могут использовать примитивы синхронизации, такие как мьютексы, семафоры и другие механизмы, чтобы координировать доступ к разделяемым ресурсам.

Планировщик использует очереди готовности, где находятся процессы и потоки, ожидающие своей очереди на выполнение.

Планировщик ОС обеспечивает иллюзию параллельного выполнения множества потоков, за счёт быстрого переключения между потоками.

## Виртуальная память

:::tip 

На эту тему есть замечательное видео <https://www.youtube.com/watch?v=x4FQ6ASzkso&t=353s>

:::

ОС должна изолировать память для каждого процесса, как в целях безопасности данных, так и для оптимизации выделения памяти для процессов. Для решения многих вопросов работы  памяти был придуман механизм **виртуальной памяти**. Как это работает?

### **Основная идея виртуальной памяти**

Программы обращаются к памяти через виртуальные адреса. Виртуальное адресное пространство -- это логическая модель памяти, которую программа видит как непрерывный и однородный блок. Хотя это совсем не так.

Процессы  не «видят» физическую память напрямую и не знают, где физически хранятся данные -- в ОЗУ или в файле подкачки.

Виртуальная память делится на блоки фиксированного размера, называемые **страницами**. Размер страницы обычно составляет 4 КБ, хотя возможны и другие размеры в зависимости от архитектуры процессора и конфигурации операционной системы (например, 2 МБ или 1 ГБ).

Физическая память также делится на блоки того же размера, называемые **фреймами** (frames). Каждая страница виртуальной памяти может быть загружена в любой фрейм физической памяти.

Фреймы выделяются для страниц по разным алгоритмам, но так или иначе, страницы идут последовательно друг за другом, то есть сначала страница под номером 1, затем страница под номером 2 и так далее, но вот страница 1 может соответствовать фрейму под номером 8 а страница 2 может соответствовать фрейму под номером 5.

То есть по факту у нас в ОЗУ беспорядочно хранятся куски данных разных процессов.

Для процесса, однако, всё выглядит как последовательное пространство, потому что он работает с виртуальной памятью, а не с физическими адресами.

![](./operating-systems-3.png)

### Зачем так перемешивать фреймы?

Непоследовательное распределение фреймов позволяет ОС эффективно использовать физическую память, избегая фрагментации и недоиспользования ресурсов.

ОС может динамически выделять и освобождать память для процессов, не привязываясь к строгой последовательности фреймов.

Когда процессу требуется память, он обращается к операционной системе с запросом на выделение необходимого объёма виртуальной памяти, в процессе заполнения страниц, им присваиваются фреймы, куда и идёт запись.

### Как сопоставляются страницы и фреймы?

Для управления соответствием между виртуальными адресами (страницами) и физическими адресами (фреймами) используется **таблица страниц (page table)**. Каждому процессу соответствует своя таблица страниц, которая содержит информацию о том, где находятся соответствующие страницы в физической памяти.

При обращении программы к виртуальному адресу процессор с помощью **MMU** **(Memory Management Unit)** переводит этот адрес в физический с использованием таблицы страниц.

При запросе определённых данных, например значения переменной, передаётся не только номер страницы, ведь страница – это тоже область памяти, нас же интересуют конкретные байты. Поэтому передаётся ещё **смещение (offset)**, на котором относительно начала этой области памяти находятся нужные нам данные.

После того как физический фрейм найден, MMU добавляет offset из виртуального адреса к началу физического фрейма, чтобы получить **точный физический адрес конкретных данных.**

![](./operating-systems-2.png)

### **Подкачка (paging)**

Когда оперативной памяти не хватает, операционная система начинает использовать **файл подкачки (swap)**, перенося туда редко используемые страницы памяти из ОЗУ. Файл подкачки располагается системой на постоянных носителях по типу SSD или HDD. Выгруженные в файл подкачки страницы возвращаются в оперативную память, когда это необходимо ИЛИ в процессе prefetching’а. Это позволяет запускать программы, которые требуют больше памяти, чем доступно физически.

То есть логическое адресное пространство программы может быть больше, чем физически есть памяти в ОЗУ, как раз таки за счёт того, что не вся память используется программой единовременно и некоторые блоки могут быть перемещены на вторичный накопитель в файл подачки.

Если процесс пытается получить доступ к странице, которая не загружена в физическую память (например, была выгружена на диск), возникает **page fault** (исключение отказа страницы), и ОС загружает страницу обратно в ОЗУ. Процесс, который запросил доступ к отсутствующей странице, **временно приостанавливается**. Как только страница загружена в ОЗУ из вторичного накопителя и таблица страниц обновлена, **процесс возобновляет свою работу с того места, на котором остановился**, теперь уже с доступом к необходимым данным.

### Prefetching

**Prefetching** (предварительная выборка) из swap -- это процесс, при котором операционная система загружает страницы памяти из файла подкачки (swap) обратно в оперативную память до того, как они понадобятся процессу. Это позволяет уменьшить задержки и повысить производительность, так как страницы могут быть уже в памяти, когда процесс захочет их использовать.

В Linux prefetching  происходит автоматически, управляется ядром операционной системы и связан с механизмами управления виртуальной памятью.. 

#### Как ОС понимает, что надо заранее подгрузить страницы?

Для принятия решения о том, какие страницы стоит заранее подгрузить, система использует несколько ключевых подходов:

1. **Анализ доступа к страницам**: 

   Linux использует алгоритмы управления памятью, которые анализируют последние обращения к страницам. Если страница недавно была выгружена в swap, но процесс снова начал активно её использовать, то система может сделать вывод, что есть высокая вероятность повторного использования этой страницы и заранее подгружает её обратно в оперативную память.

2.  **Swap readahead**: 

   Когда процесс обращается к странице, находящейся в swap, и эта страница подгружается в оперативную память, Linux может также подгружать соседние страницы, предполагая, что они также могут скоро понадобиться процессу. Это особенно полезно для процессов, которые работают с последовательными блоками данных. В Linux существует параметр **page-cluster**, который определяет количество соседних страниц, подгружаемых вместе с запрашиваемой страницей.

3. **Swappiness**: 

   Параметр swappiness в Linux регулирует агрессивность использования swap. Значение swappiness влияет на то, как часто ОС будет выгружать страницы в swap и как быстро она будет подгружать их обратно. Чем выше значение swappiness, тем чаще ОС будет использовать swap и тем быстрее она будет пытаться загружать страницы из swap обратно в память. Однако стоит отметить, что swappiness не влияет напрямую на prefetching, но косвенно может изменять поведение системы при работе со swap.

4. **Предсказание на основе предыдущей активности**:

   Linux может также использовать исторические данные о поведении процесса для предсказания будущих обращений к страницам памяти. Например, если процесс циклически обращается к определённым страницам, ОС может предугадать эти обращения и заранее подгрузить страницы из swap. Этот механизм является частью общего подхода к управлению памятью.

5. **Оценка свободной памяти**:

   Если в системе достаточно свободной оперативной памяти, ОС может быть более агрессивной в подгрузке страниц из swap, чтобы минимизировать потенциальные задержки при обращении к ним. Это делается для повышения производительности за счёт использования неактивных ресурсов. В противоположном случае, при недостатке памяти, система может менее агрессивно подгружать страницы из swap, чтобы избежать вытеснения недавно загруженных данных.





 


