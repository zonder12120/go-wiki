---
order: 4
title: "Операционные системы\_(доделать)"
---

## Прелюдия

Думаю, про ОС особо много прелюдий не надо. Если ты не потрогал сам лично  Linux, крайне рекомендую получить такой незабываемый опыт осознания разницы философий винды и линуха, хотя бы уже просто на уровне user experience, когда от стадии непринятия терминала ты доходишь до стадии презрения к виндовому powershell. Для этого просто посиди недельку на линухе как на основной системе. Ну и как факт, знания линукса сейчас требуется во многих вакансиях, так как ты будешь разрабатывать с вероятностью 99% сервисы именно под линуксоидные серваки.

## Что такое ОС

ОС по сути является **прослойкой между железом и софтом**. Она выполняет множество критически важных функций, обеспечивая взаимодействие между программами и аппаратными ресурсами компьютера. Такой вот менеджер ресурсов

## Функции ОС

Давай так, функций операционок предостаточно, но их все перечислять сейчас особого смысла нет, по крайней мере для старта в Гошке. Иначе копать вглубь можно бесконечно долго, операционные системы - это целая наука.

Хочешь углубиться в тему – погружайся в гугл, но аккуратно выбирай источники, не стоит читать первую попавшуюся статью на Хабре. Сейчас модно поливать помоями Википедию, но я бы сперва пошёл туда.

Разберём те функции, которые для нас сейчас наиболее важны для общего понимания роли ОС.

### 1\. **Управление памятью и процессами**

-  **Загрузка программ и управление памятью**: ОС загружает программы в память, распределяет память между процессами, организует виртуальную память.

-  **Исполнение запросов программ**: Обработка ввода/вывода (input/output - i/o), запуск и остановка программ, управление памятью.

### 2\. **Распределение ресурсов, многозадачность и многопоточность**

-  **Распределение ресурсов**: Эффективное распределение процессорного времени и других ресурсов между процессами.

-  **Многозадачность**: Обеспечение параллельного выполнения задач путём переключения между процессами.

-  **Многопоточность**: Поддержка выполнения нескольких потоков внутри одного процесса, что позволяет выполнять несколько задач параллельно в рамках одного приложения.

### 3\. **Безопасность и взаимодействие**

-  **Защита системы и данных**: Обеспечение безопасности системы и данных от злонамеренных действий или ошибок.

-  **Взаимодействие между процессами**: Обмен данными и синхронизация между процессами.

### 4\. **Управление данными и устройствами**

-  **Файловая система**: Управление доступом к данным на дисках.

-  **Работа с устройствами**: Стандартизованный доступ к периферийным устройствам через унифицированные интерфейсы.

## Как работает программа в ОС?

**Программа** -- это довольно большой набор инструкций, который для эффективного выполнения может быть декомпозирован программистом.

Для ОС это производится следующим образом: программа выполняется в одном или нескольких процессах, а процессы могут содержать потоки, где каждый поток отвечает за выполнение отдельных задач. Причём программист сам  управляет разделением программы на процессы и потоки.

![](./operating-systems.png)

**Процесс** можно воспринимать своего рода контейнером, внутри которого есть все необходимые ресурсы для выполнения программы. Это включает в себя индивидуальное адресное пространство памяти, дескрипторы файлов, переменные окружения и другие ресурсы.

Каждый процесс изолирован от других процессов, что позволяет защитить память и ресурсы одного процесса от вмешательства со стороны другого. При этом есть возможность использовать одну и ту же область памяти разными процессами, если есть такая необходимость.

**Поток** в контексте операционной системы -- это независимая последовательность выполнения инструкций внутри процесса. Поток разделяет ресурсы (такие как память, дескрипторы файлов и т.д.) с другими потоками того же процесса. Потоки позволяют процессу выполнять несколько задач параллельно, используя одно и то же окружение.

**Одновременно процессором может исполняться не больше потоков ОС, чем доступных потоков процессора (логических ядер)!**

Но ведь у нас постоянно запущено в ОС огромное количество процессов, как тогда они все исоплняются на компьютере, да ещё и одновременно? Тут влетает с двух ног планировщик.

## Планировщик и многопоточность

**Планировщик ОС выбирает**, какие потоки будут исполняться в данный момент на процессоре, а какие будут ожидать своей очереди. Этот выбор происходит на основе различных алгоритмов планирования, при этом поток может не выполниться до конца и уступить своё место другому потоку.

Когда планировщик решает, что поток должен уступить место другому потоку, он сохраняет состояние текущего потока (контекст) и загружает контекст нового потока. **Это называется переключением контекста.**

Потоки могут использовать примитивы синхронизации, такие как мьютексы, семафоры и другие механизмы, чтобы координировать доступ к разделяемым ресурсам.

Планировщик использует очереди готовности, где находятся процессы и потоки, ожидающие своей очереди на выполнение.

Планировщик ОС обеспечивает иллюзию параллельного выполнения множества потоков, за счёт быстрого переключения между потоками.

## Виртуальная память

:::tip 

На эту тему есть замечательное видео <https://www.youtube.com/watch?v=x4FQ6ASzkso&t=353s>

:::

ОС должна изолировать память для каждого процесса, как в целях безопасности данных, так и для оптимизации выделения памяти для процессов. Для решения многих вопросов работы  памяти был придуман механизм **виртуальной памяти**. Как это работает?

### **Основная идея виртуальной памяти**

Программы обращаются к памяти через виртуальные адреса. Виртуальное адресное пространство -- это логическая модель памяти, которую программа видит как непрерывный и однородный блок. Хотя это совсем не так.

Процессы  не «видят» физическую память напрямую и не знают, где физически хранятся данные -- в ОЗУ или в файле подкачки.

Виртуальная память делится на блоки фиксированного размера, называемые **страницами**. Размер страницы обычно составляет 4 КБ, хотя возможны и другие размеры в зависимости от архитектуры процессора и конфигурации операционной системы (например, 2 МБ или 1 ГБ).

Физическая память также делится на блоки того же размера, называемые **фреймами** (frames). Каждая страница виртуальной памяти может быть загружена в любой фрейм физической памяти.

Фреймы выделяются для страниц по разным алгоритмам, но так или иначе, страницы идут последовательно друг за другом, то есть сначала страница под номером, затем страница под номером 2 и так далее, но вот страница 1 может соответствовать фрейму под номером 8 а страница 2 может соответствовать фрейму под номером 5.

То есть по факту у нас в ОЗУ беспорядочно хранятся куски данных разных процессов.

Для процесса, однако, всё выглядит как последовательное пространство, потому что он работает с виртуальной памятью, а не с физическими адресами.

![](./operating-systems-3.png)

### Зачем так перемешивать фреймы?

Непоследовательное распределение фреймов позволяет ОС эффективно использовать физическую память, избегая фрагментации и недоиспользования ресурсов.

ОС может динамически выделять и освобождать память для процессов, не привязываясь к строгой последовательности фреймов.

Когда процессу требуется память, он обращается к операционной системе с запросом на выделение необходимого объёма виртуальной памяти, в процессе заполнения страниц, им присваиваются фреймы, куда и идёт запись.

### Как сопоставляются страницы и фреймы?

Для управления соответствием между виртуальными адресами (страницами) и физическими адресами (фреймами) используется **таблица страниц (page table)**. Каждому процессу соответствует своя таблица страниц, которая содержит информацию о том, где находятся соответствующие страницы в физической памяти.

При обращении программы к виртуальному адресу процессор с помощью **MMU** **(Memory Management Unit)** переводит этот адрес в физический с использованием таблицы страниц.

При запросе определённых данных, например значения переменной, передаётся не только номер страницы, ведь страница – это тоже область памяти, нас же интересуют конкретные байты. Поэтому передаётся ещё **смещение (offset)**, на котором относительно начала этой области памяти находятся нужные нам данные.

После того как физический фрейм найден, MMU добавляет offset из виртуального адреса к началу физического фрейма, чтобы получить **точный физический адрес конкретных данных.**

![](./operating-systems-2.png)

### **Подкачка (paging/swapping)**

Когда оперативной памяти не хватает, операционная система начинает использовать **файл подкачки (swap file)**, перенося туда редко используемые страницы памяти из RAM. Файл подкачки располагается системой на постоянных носителях по типу SSD или HDD. Выгруженные в файл подкачки страницы возвращаются в оперативную память, когда это необходимо. Это позволяет запускать программы, которые требуют больше памяти, чем доступно физически.

То есть логическое адресное пространство программы может быть больше, чем физически есть памяти в ОЗУ, как раз таки за счёт того, что не вся память используется программой единовременно и некоторые блоки могут быть перемещены на вторичный накопитель в файл подачки.

Если процесс пытается получить доступ к странице, которая не загружена в физическую память (например, была выгружена на диск), возникает **page fault** (исключение отказа страницы), и ОС загружает страницу обратно в память. Процесс, который запросил доступ к отсутствующей странице, **временно приостанавливается**. Как только страница загружена в ОЗУ и таблица страниц обновлена, **процесс возобновляет свою работу с того места, на котором остановился**, теперь уже с доступом к необходимым данным.


