---
order: 6
title: ООП в Go
---

**В Go нет классического представления ООП**, но есть некоторый схожий функционал, например взамен классическому наследованию Go предлагает композицию, она может быть знакома людям пришедшим с JS, Python или (внезапно) Rust.

Также в Go есть методы и интерфейсы, но их реализация нестандартная, поэтому нужно познакомиться с ними поближе.

## Методы

В Go методы - это функции, которые имеют специальный получатель/приёмник (receiver), связанный с конкретным типом.

Reciver указывается перед именем функции, что позволяет вызывать метод для конкретного значения этого типа. Методы могут быть определены как для значений, так и для указателей на типы.

В Go можно объявлять методы для пользовательских типов данных, определенных в текущем пакете, в том числе и для структур.

Как это пишется?

![](./_index.jpeg)

На картинке выше можно увидеть, что аргументы метода странно описаны.

**Оператор упаковки** (многоточие) перед аргументом означает, что метод является **вариативной функцией,** то есть может в себя принимать произвольное количество аргументов.

Есть ещё **оператор распаковки**, он пишется после имени переменной, например, когда мы хотим добавить в слайс элементы другого слайса. Мы не можем просто прибавить слайс через функцию **append()**, мы сначала его должны распаковать:

```
slc1 := []int{0, 1, 2, 3}

slc2 := []int{4, 5, 6, 7}

slc1 = append(slc1, slc2...)

fmt.Println(slc1) // [0 1 2 3 4 5 6 7]
```

### Примеры создания методов:

#### Пользовательский тип на основе встроенного типа int:

```
// Объявление типа
type MyInt int

// Объявление метода
func (i MyInt) Add(n MyInt) MyInt {
	return i + n
}

func main() {
	var num MyInt = 1

	fmt.Println(num.Add(1)) // 2
}
```

#### Структура:

```
// Структура
type Person struct {
	Name  string
	Age uint8
}

// Метод структуры Person
// Использование указателя для передачи структуры, чтобы можно было изменить значение поля Age
func (p *Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

В примере со структурой видно, что структуру в метод мы передаём по указателю, чтобы иметь доступ к оригинальному экземпляру ~~класса~~ коллекции.

Представим, что мы не использовали бы указатель. В таком случае, вызов метода из созданного экземпляра структуры создаст копию этого экземпляра, и если метод реализует изменение поля этой структуры, то это изменение применится к копии.

Проверим это:

```Go
type Person struct {
	Name  string
	Age uint8
}

// Передаём структуру в метод по значению
func (p Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya = danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

Если бы мы не переопределили значение переменной `danya`, то на выводе у нас было бы число 26, а строчка с вызовом метода была бы подчёркнута как некорректная.

В общем, передача структуры по указателю позволяет управлять исходным экземпляром + снижает нагрузку на память, так как не передаётся полная копия всей структуры, а всего лишь адрес весом 8 байт в 64 битной системе или 4 байта в 32 битной.

## Конструктор (best practice)

Я перерыл весь интернет, и пока что, на момент написания этой главы (31.07.2024), это самая актуальная информация.

Общепринятой лучшей практикой в Go является использование указателя на структуру при создании экземпляра. Более того, принято реализовывать конструкторы для создания экземпляра структуры. Встроенного конструктора нет, нужно создавать для каждой структуры функцию, которая будет возвращать указатель на экземпляр структуры.

Преимущества:

-  Передача указателя позволяет избежать копирования всей структуры, что может быть дорогостоящим для больших структур

-  Возвращая указатель, мы можем изменять поля структуры после её создания

-  В Go интерфейсы часто работают с указателями на структуры, что позволяет реализовывать методы интерфейсов, изменяющие состояние объекта

Пример:

```Go
type Person struct {
	Name    string
	Age     uint8
	FavSong string
}

//Метод-конструктор, возвращающий экземпляр структуры. Принято обзывать "New + название структуры"
func NewPerson(name string, age uint8, favSong string) *Person {
	return &Person{
		Name:    name,
		Age:     age,
		FavSong: favSong,
	}
}

func main() {
	hughie := NewPerson("Hughie", 32, "Billy Joel - Pressure")
}
```

## Композиция/встраивание (наследование)

Аналог наследованная из классического ООП.

**Композиция** - это возможность встроить однин структурный тип в другой с наследованием методов и полей.

Давайте на более ёмком примере разберём подходы к инициализации вложенных структур.

Создадим структуры Animal, Pet (наслледник Animal) и Cat (наследник Pet), заодно реализуем enum для поля Gender.

Рекомендую копировать примеры в IDE и пощупать, как это всё работает.

```
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Animal struct {
	WeightKg float32
	SpeedKmH uint8
}

func (a *Animal) Say(sound string) string {
	fmt.Println(sound)
	return sound
}

type Pet struct {
	Animal Animal
	Name   string
	Age    float32
	Gender Gender
}

type Cat struct {
	Pet   Pet
	Breed string
}

func NewCat(name string, age float32, gender Gender, breed string, weghtKg float32, speedKmH uint8) *Cat {
	return &Cat{
		Pet: Pet{
			Animal: Animal{
				WeightKg: weghtKg,
				SpeedKmH: speedKmH,
			},
			Name:   name,
			Age:    age,
			Gender: gender,
		},
		Breed: breed,
	}
}

func main() {
	asya := NewCat("Ася", 0.5, Female, "бенгал", 2.5, 8)

	fmt.Println(asya) // &{{{2.5 8} Ася 0.5 самка} бенгал}

	asya.Pet.Animal.Say("Мяу") // Мяу
}
```

Прошу обратить внимание, как я расположил поля структур, в порядке убывания, вспоминаем про выравнивание. Можешь перепроверить размеры, используя пакет `unsafe` и функцию `Sizeof()`

:::note 

Хочу обратить внимание на то, что **при наследовании структуры,** **создаётся её экземпляр**.

А доступ к полям и методам этого экземпляра есть **напрямую из наследника**, поэтому передавать наследуемые структуры по указателю нет смысла.

:::

### Подытожим

В нашем примере мы создали **экземпляр структуры** `Cat` через функцию-конструктор, которая является **наследником структуры** `Pet`, которая в свою очередь является **наследником структуры** `Animal`. А так же реализовали метод `Say()` для структуры `Animal`

## Встраивание

Вовсе не обязательно использовать явное именование полей при композиции. Мы можем просто указать тип структуры, которую **встраиваем** в нашу структуру.

Эта форма композиции называется **встраивание**.

При **встраивании** поля и методы встроенной структуры становятся доступными напрямую, как если бы они были частью внешней структуры.

Пример:

```
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Human struct {
	HeightM	float32
	Weight	float32
	Gender Gender
	Age uint8
}

func (h *Human) Say(s string) {
	fmt.Println(s)
}

type Person struct {
	Human
	Name string
	FavCloth string
}

func NewPerson(name string, age uint8, gender Gender, height float32,) *Person {
	return &Person{
		Human: Human{
			Gender: gender
		}
	}
}

func main () {
	
}
```

### Передача структуры по значению или по указателю?

:::lab 

Выше уже описаны общепринятые практики, но всё же есть спорные моменты, хочу дать полную информацию, которую смог добыть

:::

Когда мы передаём структуру по значению, мы создаём копию, что, разумеется, создаёт некоторые накладные расходы на память. Но важно понимать, когда использовать указатели, а когда - оно того не стоит.

Из раздела “База”, статьи про процессора, мы знаем, что кэш делится на кэш-линии, длиной по 64 байта.

И обычно принято ориентироваться на то, что если структура весит <= 64 байт, то нет смысла использовать указатели для передачи структуры, процесс копирования и так будет очень быстрым.

А вот если > 64 байт…

Да в целом это холивар, здесь все по-своему на это смотрят: <https://habr.com/ru/companies/it-guide/articles/744046/>

Но вот немного слов ЗА и ПРОТИВ:

Если метод **не должен изменять структуру** (например, он только читает данные), можно передавать структуру **по значению**. Это помогает защитить данные от нежелательных изменений.

Передача по значению может упростить код, избегая проверок на nil.

#### **Типичная практика**:

-  Для структур размером до 2-3 кэш-линий (т.е. до 128-192 байт) передача по значению обычно приемлема.

-  Для структур размером больше 3 кэш-линий (более 192 байт) предпочтительнее передавать по указателю.

#### Примерные размеры

-  **Маленькие структуры** (до 64 байт): могут включать несколько примитивных полей, таких как `int`, `float64`, `bool`, и могут быть переданы по значению без значительных накладных расходов.

-  **Средние структуры** (64-192 байт): структуры, включающие несколько массивов или строк, и могут быть переданы по значению в зависимости от контекста и использования.

-  **Большие структуры** (более 192 байт): структуры, содержащие большие массивы, срезы или множество полей, чаще передаются по указателю для улучшения производительности.

#### **Консистентность**:

Важно придерживаться единого стиля на протяжении всего проекта. Если принято во всём проекте передавать структуру по указателю, то необходимо придерживаться этого решения, учитывая все накладные расходы при разработке (например проверки на nil).


