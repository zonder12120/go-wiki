---
order: 6
title: ООП в Go
---

**В Go нет классического представления ООП**, но есть некоторый схожий функционал, например взамен классическому наследованию Go предлагает **композицию**, она может быть знакома людям пришедшим с JS, Python или (внезапно) Rust.

Также в Go есть **методы** и **интерфейсы**, но их реализация нестандартная, поэтому нужно познакомиться с ними поближе.

## Методы

В Go методы - это функции, которые имеют специальный получатель/приёмник (receiver), связанный с конкретным типом.

**Reciver** указывается перед именем функции, он позволяет вызывать метод для конкретного значения этого типа. Методы могут быть определены как для значений, так и для указателей на типы.

В Go можно объявлять методы для пользовательских типов данных, определенных в текущем пакете, в том числе и для структур.

Как это пишется?

![](./_index.jpeg)

На картинке выше можно увидеть, что аргументы метода странно описаны.

**Оператор упаковки** (многоточие) перед аргументом означает, что метод является **вариативной функцией,** то есть может в себя принимать произвольное количество аргументов. Из определения оператора упаковки можно понять, что эти аргументы куда-то запакуются. Очевидно, они образуют слайс целевого типа данных.

Есть ещё **оператор распаковки (spread operator)**, он пишется после имени переменной, например, когда мы хотим добавить в слайс элементы другого слайса. Мы не можем просто прибавить слайс через функцию **append()**, мы сначала его должны распаковать:

```go
slc1 := []int{0, 1, 2, 3}

slc2 := []int{4, 5, 6, 7}

slc1 = append(slc1, slc2...)

fmt.Println(slc1) // [0 1 2 3 4 5 6 7]
```

### Примеры создания методов:

#### Пользовательский тип на основе встроенного типа int:

```go
// Объявление типа
type MyInt int

// Объявление метода
func (i MyInt) Add(n MyInt) MyInt {
	return i + n
}

func main() {
	var num MyInt = 1

	fmt.Println(num.Add(1)) // 2
}
```

#### Структура:

```go
// Структура
type Person struct {
	Name  string
	Age uint8
}

// Метод структуры Person
// Использование указателя для передачи структуры, чтобы можно было изменить значение поля Age
func (p *Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

В примере со структурой видно, что структуру в метод мы передаём по указателю, чтобы иметь доступ к оригинальному экземпляру ~~класса~~ коллекции.

Представим, что мы не использовали бы указатель. В таком случае, вызов метода из созданного экземпляра структуры создаст копию этого экземпляра, и если метод реализует изменение поля этой структуры, то это изменение применится к копии.

Проверим это:

```go
type Person struct {
	Name  string
	Age uint8
}

// Передаём структуру в метод по значению
func (p Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya = danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

Если бы мы не переопределили значение переменной `danya`, то на выводе у нас было бы число 26, а строчка с вызовом метода была бы подчёркнута как некорректная.

В общем, передача структуры по указателю позволяет управлять исходным экземпляром + снижает нагрузку на память, так как не передаётся полная копия всей структуры, а всего лишь адрес весом 8 байт в 64 битной системе или 4 байта в 32 битной.

## Конструктор (best practice)

Я перерыл весь интернет, и пока что, на момент написания этой главы (31.07.2024), это самая актуальная информация.

Общепринятой лучшей практикой в Go является использование указателя на структуру при создании экземпляра. Более того, принято реализовывать конструкторы для создания экземпляра структуры. Встроенного конструктора нет, нужно создавать для каждой структуры функцию, которая будет возвращать указатель на экземпляр структуры.

Преимущества:

-  Передача указателя позволяет избежать копирования всей структуры, что может быть дорогостоящим для больших структур

-  Возвращая указатель, мы можем изменять поля структуры после её создания

-  В Go интерфейсы часто работают с указателями на структуры, что позволяет реализовывать методы интерфейсов, изменяющие состояние объекта

Пример:

```go
type Person struct {
	Name    string
	Age     uint8
	FavSong string
}

//Метод-конструктор, возвращающий экземпляр структуры. Принято обзывать "New + название структуры"
func NewPerson(name string, age uint8, favSong string) *Person {
	return &Person{
		Name:    name,
		Age:     age,
		FavSong: favSong,
	}
}

func main() {
	hughie := NewPerson("Hughie", 32, "Billy Joel - Pressure")
}
```

НО есть исключение, когда лучше всё-таки не использовать указатель на структуру, а передавать её по значению, об этом ниже.

## Композиция/встраивание (наследование)

Аналог наследованная из классического ООП.

**Композиция** - это возможность встроить однин структурный тип в другой с наследованием методов и полей.

Давайте на более ёмком примере разберём подходы к инициализации вложенных структур.

Создадим структуры Animal, Pet (наслледник Animal) и Cat (наследник Pet), заодно реализуем enum для поля Gender.

Рекомендую копировать примеры в редактор кода и пощупать, как это всё работает.

```go
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Animal struct {
	WeightKg float32
	SpeedKmH uint8
}

func (a *Animal) Say(sound string) string {
	fmt.Println(sound)
	return sound
}

type Pet struct {
	Animal Animal
	Name   string
	Age    float32
	Gender Gender
}

type Cat struct {
	Pet   Pet
	Breed string
}

func NewCat(name string, age float32, gender Gender, breed string, weghtKg float32, speedKmH uint8) *Cat {
	return &Cat{
		Pet: Pet{
			Animal: Animal{
				WeightKg: weghtKg,
				SpeedKmH: speedKmH,
			},
			Name:   name,
			Age:    age,
			Gender: gender,
		},
		Breed: breed,
	}
}

func main() {
	asya := NewCat("Ася", 0.5, Female, "бенгал", 2.5, 8)

	fmt.Println(asya) // &{{{2.5 8} Ася 0.5 самка} бенгал}

	asya.Pet.Animal.Say("Мяу") // Мяу
}
```

Прошу обратить внимание, как я расположил поля структур, в порядке убывания, вспоминаем про выравнивание. Можешь перепроверить размеры, используя пакет `unsafe` и функцию `Sizeof()`

:::note 

Хочу обратить внимание на то, что **при наследовании структуры,** **создаётся её экземпляр**.

А доступ к полям и методам этого экземпляра есть **напрямую из наследника**, поэтому передавать наследуемые структуры по указателю нет смысла.

:::

### Подытожим

В нашем примере мы создали **экземпляр структуры** `Cat` через функцию-конструктор, которая является **наследником структуры** `Pet`, которая в свою очередь является **наследником структуры** `Animal`. А так же реализовали метод `Say()` для структуры `Animal`

## Встраивание

Вовсе не обязательно использовать явное именование полей при композиции. Мы можем просто указать тип структуры, которую **встраиваем** в нашу структуру.

Эта форма композиции называется **встраивание**.

При **встраивании** поля и методы встроенной структуры становятся доступными напрямую, как если бы они были частью внешней структуры.

Пример:

```go
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "Мужчина"
	case Female:
		return "Женщина"
	}
	return "ошибка"
}

type Human struct {
	Gender   Gender
	HeightM  float32
	WeightKg float32
	Age      uint8
}

func (h *Human) Say(s string) {
	fmt.Println(s)
}

type Person struct {
	Human
	Name     string
	FavCloth string
}

func NewPerson(name string, age uint8, gender Gender, heightM float32, weightKg float32, favCloth string) *Person {
	return &Person{
		Human: Human{
			Gender:   gender,
			HeightM:  heightM,
			WeightKg: weightKg,
			Age:      age,
		},
		Name:     name,
		FavCloth: favCloth,
	}
}

func main() {
	billy := NewPerson("Billy", 49, Male, 1.85, 87, "coat")

	// Получаем прямой доступ к методу, без вложенности 
	billy.Say(fmt.Sprintf("Oi! I love my focking %v!", billy.FavCloth))
}
```

### Передача структуры по значению или по указателю?

:::lab 

Выше уже описаны общепринятые практики, но всё же есть спорные моменты, хочу дать полную информацию, которую смог добыть.

Да и от проекта к проекту люди могут навязывать свои стандарты, поэтому важно знать, что и когда лучше всего использовать, чтобы навязать свои))))

:::

Когда мы передаём структуру по значению, мы создаём копию, что, разумеется, создаёт некоторые накладные расходы на память. Но важно понимать, **когда использовать указатели, а когда - оно того не стоит.**

Из раздела “База”, статьи про процессора, мы знаем, что кэш делится на кэш-линии, длиной по 64 байта (в случае большинства современных процессоров).

И обычно принято ориентироваться на то, что если структура весит <= 64 байт, то нет смысла использовать указатели для передачи структуры, процесс копирования и так будет очень быстрым.

А лишний раз использовать указатели = захламлять кучу = напрягать garbage collector, который достаточно дорогой в Go.

:::info 

1. В Go сборщик мусора может стать узким местом в производительности, особенно при активном создании и удалении объектов в куче.

2. Избыточное использование указателей может увеличить нагрузку на сборщик мусора, что приведет к снижению производительности.

:::

А вот если структура > 64 байт…

Да в целом это холивар, здесь все по-своему на это смотрят: <https://habr.com/ru/companies/it-guide/articles/744046/>

Но вот немного слов ЗА и ПРОТИВ:

-  Если метод **не должен изменять структуру** (например, он только читает данные), можно передавать структуру **по значению**. Это помогает защитить данные от нежелательных изменений.

-  Передача структур по значению в метод или переменную может упростить код, избегая проверок на nil.

:::note 

**Каждый раз, когда ты работаешь с указателем, тебе нужно проверять, не равен ли он nil**. Пропуск такой проверки может привести к панике (runtime panic) при попытке доступа к полям структуры через nil-указатель.

:::

#### **Можно ориентироваться на следующее**:

-  Для структур размером до 2-3 кэш-линий (т.е. до 128-192 байт) передача по значению обычно приемлема.

-  Для структур размером больше 3 кэш-линий (более 192 байт) предпочтительнее передавать по указателю.

#### Примерные размеры

-  **Маленькие структуры** (до 64 байт): могут включать несколько примитивных полей, таких как `int`, `float64`, `bool`, и могут быть переданы по значению без значительных накладных расходов.

-  **Средние структуры** (64-192 байт): структуры, включающие несколько массивов или строк, и могут быть переданы по значению в зависимости от контекста и использования.

-  **Большие структуры** (более 192 байт): структуры, содержащие большие массивы, срезы или множество полей, чаще передаются по указателю для улучшения производительности.

#### **Консистентность**

Важно придерживаться единого стиля на протяжении всего проекта. Если принято во всём проекте передавать структуру по указателю, то необходимо придерживаться этого решения, учитывая все накладные расходы при разработке (например, проверки на nil).

## Интерфейсы

:::lab 

Частично основано на статье: <https://habr.com/ru/companies/vk/articles/463063/>

И чуть-чуть отсюда: <https://sergeyem.ru/blog/111>

Ну и можно глянуть видос умного человека: <https://www.youtube.com/watch?v=eYHCCht8eX4>

:::

Ибо зачем что-то изобретать, когда уже какой-то умный человек всё написал за меня, я же только немного переформулирую, как бы это рассказывал я.

Интерфейсы в Go реализуют концепцию **полиморфизма** из ООП (это когда 2 разные сущности могут выполнять одни и те же действия).

Интерфейс - это тип, который характеризуется не значениеми, как все остальные типы, а **методами.**

Интерфейс описывает внутри себя методы, которые должен **реализовать** в себе тип, чтобы  принадлежать этому интерфейсу.

То есть, хотим мы этого или нет, тип будет принадледжать интерфейсу, если реализует методы этого интерфейса.

“Если нечто выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка” – Ричард Паттерсон\*\*.\*\*

Это называется Утиный Тест, в Go применяется тот же тип для определения принадлежности интерфейсу, называется это **duck typing (утиная типизация).**

:::info 

Мы говорим, что что-то удовлетворяет этому интерфейсу (или реализует этот интерфейс), если у этого чего-то есть метод с конкретной сигнатурой, которую описывает интерфейс.

:::

### Примеры

:::info 

**BEST PRACTICE**

1. Согласно принципу разделения интерфейсов, **более разумно определять много маленьких интерфейсов, чем один большой.** Этот подход соответствует принципам SOLID (I = Interface Segregation Principle), сформулированным сторонником чистого кода Робертом К. Мартином (Дядя Боб). Согласно этому принципу, интерфейс должен иметь столько методов, сколько ему необходимо.

2. Интерфейсы лучше размещать в месте их использования, так как это позволяет делать их более компактными, читаемыми + уменьшаем связанность системы (наш пакет с интерфейсом не будет зависеть от другого пакета), нам проще создавать моки для тестов. Есть и минус: придётся править в разных местах сигнатуру методов. Подробнее здесь (есть таймкоды): <https://www.youtube.com/watch?v=eYHCCht8eX4>

:::

Допустим, у нас есть интерфейс `talker`, который должен **реализовать** метод `say()`, но при описании метода в интерфейсе **не нужно забывать точно указывать сигнатуру метода.**

Ещё у нас есть структура `human`, которая реализует метод `say()`, а ещё структура `parrot`, которая тоже реализует метод `say()`, а заодно функция `showSpeech()`, которая принимает в себя переменную типа `talker`, и выводит “речь” на экран.

```go
package main

import (
	"fmt"
)

type talker interface {
	say(string) string
}

type human struct {
	name string
}

func newHuman(n string) *human {
	return &human{
		name: n,
	}
}

func (h human) say(s string) string {
	return fmt.Sprintf("Привет, меня зовут %v, хотел сказать: %v", h.name, s)
}

type parrot struct{}

func (p parrot) say(s string) string {
	return fmt.Sprintf("Чик-чирик, %v!", s)
}

func showSpeech(t talker, s string) {
	fmt.Println(t.say(s))
}

func main() {
	jhon := newHuman("Jhon")
	parrot := parrot{}

	showSpeech(jhon, "интерфейсы не сложные")
	showSpeech(parrot, "интерфейсы не сложные")
}
```

Из примера видно, что функция `showSpeech()` смогла принять в себя 2 разных типа, потому что они **удовлетворяют** интерфейсу `talker`. То есть функция `showSpeech()` является **гибкой**. Вот он, полиморфизм!

Но если бы мы передавали в функцию `showSpeech()` тип, который не реализует метод `say()`, то мы бы получили ошибку, например:

```go
//…остальной код

type rat struct{}

func main() {
	remy := &rat{}
	showSpeech(remy, "Я не говорящий крыс!")
}
```

Подсветится в IDE:

```plaintext
cannot use remy (variable of type *rat) as talker value in argument to showSpeech: 
*rat does not implement talker (missing method say)
```

:::info 

Для небольших интерфейсов, состоящих из одного-трех методов, установилось соглашение об именовании. Оно последовательно применяется в стандартной библиотеке.

Имя интерфейса состоит из имени метода и букв **«er»** в конце. Метод String() становится интерфейсом Stringer, а Read() - интерфейсом Reader.

Преимущество такого соглашения очевидно: даже без документации понятно, какие методы содержат интерфейс ReadWriter или ReadWriteCloser.

:::

### Чем полезны интерфейсы?

-  **Уменьшение дублирования кода.** Интерфейсы позволяют описать общее поведение различных типов, что снижает необходимость написания шаблонного кода.

-  **Облегчение модульных тестов.** Интерфейсы позволяют легко заменять реальные объекты заглушками или мока-объектами при тестировании. Это полезно для тестирования компонентов в изоляции от внешних зависимостей, таких как базы данных или сетевые соединения.

-  **Модульность кода.** Интерфейсы помогают отвязывать части кодовой базы, что облегчает рефакторинг и изменение кода. Это способствует созданию более модульного и гибкого дизайна приложения. Связанность подразумевает под собой зависимость одной части программы от другой, в нашем случае когда один пакет зависит от другого, поэтому при удалении оного программа работать перестанет.

Всё это вместе помогает писать более простой и чистый код в меньшее количество символов, а как мы знаем, **чем меньше кода, тем меньше багов!**

Главное следовать принципам чистого кода, чуть ниже будет про загрязнение кода.

### Загрязнение

Определять и использовать интерфейсы в Go очень просто. На практике это обстоятельство часто приводит к тому, что разработчики определяют слишком много интерфейсов для функций. То, что это можно сделать без особых усилий, не всегда имеет смысл. Если в коде определяется слишком много или даже ненужных интерфейсов, то мы говорим о загрязнении кода: interface pollution. Но насколько много - это слишком много?

Как уже объяснялось в начале, разработчики вынуждены прибегать к интерфейсам, если хотят использовать функцию более чем для одного типа. Исходя из этого, легко выявить ненужные интерфейсы. Интерфейсы, имеющие только одну реализацию, не нужны. Вместо этого достаточно использовать в функции конкретный тип и тем самым избежать излишней абстракции.

Возможно, разработчики работали на C# или Java, и им показалось естественным создавать интерфейсы перед тем, как писать реализацию. Однако в Go всё не так.

Как мы уже говорили, интерфейсы создаются для создания абстракций. И главное предостережение при программировании с использованием абстракций - помнить, что абстракции нужно не создавать, а раскрывать. Что это означает? Это означает, что не следует начинать создавать абстракции в коде, если для этого нет непосредственной причины. Мы не должны проектировать интерфейсы, а ждать когда они нам понадобятся. Другими словами, мы должны создавать интерфейс тогда, когда он нам нужен, а не тогда, когда мы предвидим, что он может нам понадобиться.

:::info 

*«Таким образом, мы должны быть осторожны при создании абстракций в нашем коде - абстракции должны быть обнаружены, а не созданы. Обычно мы, разработчики программного обеспечения, слишком усложняем свой код, пытаясь угадать идеальный уровень абстракции, исходя из того, что, по нашему мнению, может понадобиться в дальнейшем. Этого процесса следует избегать, поскольку в большинстве случаев он загрязняет наш код ненужными абстракциями, делая его более сложным для восприятия.*

*Не проектируйте интерфейсы, а открывайте их».*

\-Роб Пайк

:::

### Чтооо? Тип Any в Go???

В Go можно использовать пустой интерфейс, например `interface{}`, в таком случае, если что-то принимает в себя аргумент типа `interface{}`, то в это что-то можно впихнуть переменную любого типа.

Например:

```go
package main

import "fmt"

func main() {
    person := make(map[string]interface{}, 0)

    person["name"] = "Alice"
    person["age"] = 21
    person["height"] = 167.64

    fmt.Printf("%+v", person)
}
```

Ну или вовсе мы могли бы объявить пустой интерфейс с именем `any` и тогда бы мы добавили бы капельку TypeScript в Go :)

Но есть нюанс в таком читерстве, помимо того, что это не безопасно с точки зрения ошибок.

Интерфейсы скрывают информацию о переменных, находящихся за ними. При их использовании невозможно получить прямой доступ к базовой переменной.

**То есть все значения теряют свой базовый тип**.

Например, если мы захотим прибавить к `person.age` единичку, то получим ошибку

```plaintext
invalid operation: person["age"] + 1 (mismatched types interface {} and int)
```

Поэтому при таком подходе надо сначала приводить значение из интерфейсного типа обратно к своему базовому типу, а затем над ним производить операции:

```go
package main

import "log"

func main() {
    person := make(map[string]interface{}, 0)

    person["name"] = "Alice"
    person["age"] = 21
    person["height"] = 167.64

    age, ok := person["age"].(int)
    if !ok {
        log.Fatal("could not assert value to int")
        return
    }

    person["age"] = age + 1

    log.Printf("%+v", person)
}
```

Как видно, приведение интерфейсного типа происходит так: переменная, точка, целевой тип в скобках.

Согласен, не очень удобно, поэтому часто с этой штукой не играйся, тут тебе не динамическая типизация!

### Как получить доступ к полям через интерфейс?

Допустим, у нас есть интерфейс `talker` с методом `say()`, ему удовлетворяет структура `human`, а ещё у нас есть функция `changaName()`, которая принимает в себя интерфейс `talker` и строку с новым именем `newName`. Но вот чтобы поменять это имя, нам нужно получить доступ к полю `name`. А через обращение к интерфейсу мы получить доступ к полю не можем, у нас об интерфейсе известен только метод.

Но есть в **Go** и на эту проблему решение – **утверждение типа**!

Мы проверяем, является ли интерфейс конкретным экземпляром нужного нам типа, а затем записываем туда переменную (чтобы иметь доступ к полю, именно указатель). В случае, если у нас **true,** меняем имя на заданное в строке.

```go
package main

import (
	"fmt"
)

type talker interface {
	say()
}

type human struct {
	name string
}

func newHuman(n string) *human {
	return &human{
		name: n,
	}
}

func (h human) say() {
	fmt.Printf("Привет, меня зовут %v", h.name)
}

func changeName(t talker, newName string) {
	h, ok := t.(*human)    // Записываем указатель на структуру (если ок) и булево значение
	if ok {
		h.name = newName   // Меняем значение поля структуры
	}
}

func main() {
	jhon := newHuman("Jhon")
	changeName(jhon, "Иван")
	jhon.say()
}
```

Разумеется, в случае с интерфейсом, у нас будет несколько типов. И чтобы не перебирать if else как дурачки, мы можем использовать `switch-case` так:

```go
package main

import (
	"fmt"
)

type talker interface {
	say()
}

type human struct {
	name string
}

func newHuman(n string) *human {
	return &human{
		name: n,
	}
}

func (h human) say() {
	fmt.Printf("\nПривет, меня зовут %v", h.name)
}

type parrot struct {
	color string
}

func newParrot(c string) *parrot {
	return &parrot{
		color: c,
	}
}

func (p parrot) say() {
	fmt.Printf("\nЧик-чирик, мой цвет %v!", p.color)
}

func changeInfo(t talker, newInf string) {
	switch t := t.(type) {
	case *human:
		t.name = newInf
	case *parrot:
		t.color = newInf
	}
}

func main() {
	jhon := newHuman("Jhon")
	parrot := newParrot("жёлтый")

	changeInfo(jhon, "Иван")
	changeInfo(parrot, "зелёный")

	jhon.say()
	parrot.say()
}
```

То есть прямо в свитче присваиваем переменной `t` тип, который удовлетворяет какому-то из кейсов, а затем просто одной строчкой меняем значение поля. А то я видал и другие вариации такого свитч-кейса, когда внутри него городят ещё и утверждение типа, мало того, создавая как и дополнительные строки кода, так и дополнительные переменные.

### **Полезные интерфейсные типы**

Вот короткий список самых востребованных и полезных интерфейсных типов из стандартной библиотеки. Если вы с ними ещё не знакомы, то рекомендую почитать соответствующую документацию:

-  [builtin.Error](https://golang.org/pkg/builtin/#error)

-  [fmt.Stringer](https://golang.org/pkg/fmt/#Stringer)

-  [io.Reader](https://golang.org/pkg/io/#Reader)

-  [io.Writer](https://golang.org/pkg/io/#Writer)

-  [io.ReadWriteCloser](https://golang.org/pkg/io/#ReadWriteCloser)

-  [http.ResponseWriter](https://golang.org/pkg/net/http/#ResponseWriter)

-  [http.Handler](https://golang.org/pkg/net/http/#Handler)