---
order: 4
title: Slices, срезы
---

Срезы - это мощная надстройка над массивами

Сейчас ты поймёшь, почему срезы названы именно так

Срез состоит из:

{% table %}

---

*  {% colwidth=[128] %}

   **ptr** uintptr

*  {% colwidth=[379] %}

   Pointer - указатель на первый элемент слайса

---

*  {% colwidth=[128] %}

   **len** int

*  {% colwidth=[379] %}

   Length - длина слайса

---

*  {% colwidth=[128] %}

   **cap** int

*  {% colwidth=[379] %}

   Capacity - ёмоксть слайса

{% /table %}

То есть сам срез в себе ничего не хранит, а его размер зависит от разрядности системы. Если 64, то **ptr, len** и **cap** занимают в памяти по 8 байт, а слайс в сумме весть **24 байта**, если разрядность 32 бита, то соотвтественно слайс будет весить **12 байт**

**Но слайс базируется на массиве!**

**ptr** указывает на N-ый элемент базового массива. Причём массив может быть как существующим, так и создаваться при инициализации среза.

В первом случае это будет выглядеть примерно так:

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

fmt.Println(slc) // [2 3 4]
```

А чтобы стало понятнее, изобразим границы массива фигурными скобками, а среза - квадратными:

*{1,* **\[2, 3, 4\]**, *5}*

То есть обрезается какая-то часть массива по интервалу

При этом требуется также обратить внимание на то, что интервал является **полуоткрытым,** то есть мы объявили срез так: `slc := arr[1:4]`, указав индекс 1 и 4, но индекс 1 в интервал вошёл, а индекс 4 - нет. То есть начальный индекс в полуоткрытый интервал входит, а конечный - нет.

В этом случае у среза `slc`: 

{% table %}

---

*  {% colwidth=[124] isHeader=true %}

   слайс slc

*  {% colwidth=[114] isHeader=true %}

   Значение

---

*  {% colwidth=[124] %}

   **ptr**

*  {% colwidth=[114] %}

   &arr\[1\]

---

*  {% colwidth=[124] %}

   **len**

*  {% colwidth=[114] %}

   3

---

*  {% colwidth=[124] %}

   **cap**

*  {% colwidth=[114] %}

   4

{% /table %}

Емкость слайса `slc` равна **4**, потому что это максимальное количество элементов, которое можно вместить в слайс, начиная с его первого элемента `arr[1]`.

Вставка значений производится функцией `append(slice, value)`

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Println(slc) // [2 3 4 33]
fmt.Println(arr) // [1 2 3 4 33]
```

Как стало понятно из кода выше, при вставке в слайс нового значения, значение элемента базового массива, который стоял на этом месте, перезаписывается, а **len** слайса увеличивается на 1

Так же мы можем заметить, что подошли к конечному значению базового массива. Что будет, если мы добавим ещё один элемент, ведь у нашего слайса `slc` теперь и **len** = 4, и **cap** = 4

А в таком случае у нас просто создаётся новый базовый массив и ссылка на **ptr** теперь будет в себе хранить ссылку на нулевой элемент этого нового массива.

При этом новый базовый массив вдвое больше длины слайса до добавления элемента (расширения), вот пример:

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Printf("len: %d, cap: %d», len(slc), cap(slc)) 
// len = 4, cap = 4

slc = append(slc, 44) 

fmt.Printf("len: %d, cap: %d», len(slc), cap(slc)) 
// len = 5, cap = 8


fmt.Println(slc) // [2 3 4 33 44]

// Новый базовый массив = {2, 3, 4, 33, 44, 0, 0, 0}
```

При этом можно заметить, что в базовом массиве добавленные элементы **инициализируются нулевыми значениями** типа массива.

*Тут небольшая ремарка, вдвое слайс будет увеличиваться на какого-то предела, дальше коэффициент уменьшается, зависит от реализации компилятора, подробнее в исходном коде компилятора*

При таком расширении слайса, в случае, если **старый базовый массив** больше не используется, он **удаляется сборщиком мусора**. 

Это удобно, позволяет экономить память, **но тут кроется опасность.** 

Если заранее не выделить достаточно памяти для слайса и часто в него что-то добавлять, то он будет расширяться большое количество раз, что может заставить создавать новые массивы чаще и работать сборщик мусора довольно много, **увеличивая нагрузку на память и процессор**.

А как нам заранее аллоцировать память для слайса?

Есть ещё метод объявления слайса:

```Go
slc := make([]int, 100)
```

Таким образом мы создали слайс с размером 100 и ёмкостью 100

```Go
slc := make([]int, 10, 100)
```

А так мы уже создали слайс длиной 10 и ёмкостью 100

В чём разница? Сначала можно подумать, что и так, и так создаётся базовый массив со 100 штуками нулей, **но это не так**

**Тут важная разница**, во втором случае у нас резервируется память, которая необходима для хранения 100 элементов типа int, **но инициализируются только первые 10**, остальные элементы **неинициализированы**, что означает, что они будут содержать мусорные значения, оставшиеся от предыдущего использования памяти.

Основное преимущество здесь в **экономии вычислительных ресурсов и времени**, поскольку нет необходимости перезаписывать весь массив до его полной длины.

Ещё одним заблуждением является, что не инициализированный слайс будет равен **nil**

```Go
var slc []int
```

Но если мы выведем его значение, мы получим просто пустой слайс `[]` 

Более того, этот слайс, как я уже говорил в начале, **будет так же весить 24 байта**, так как его структура не поменяется, поменяются только значения:

{% table %}

---

*  {% colwidth=[124] isHeader=true %}

   слайс slc

*  {% colwidth=[648] isHeader=true %}

   Значение

---

*  {% colwidth=[124] %}

   **ptr** unintpitr

*  {% colwidth=[648] %}

   Указывает на **начало** выделенной области памяти

---

*  {% colwidth=[124] %}

   **len** int

*  {% colwidth=[648] %}

   0

---

*  {% colwidth=[124] %}

   **cap** int

*  {% colwidth=[648] %}

   0

{% /table %}

При декларации `var slc []int` **автоматически** происходит **выделение памяти** для нового среза.

**Ptr** указывает на **начало** выделенной области памяти, эта область памяти **может быть пустой**, но **не имеет нулевой длины**

Так же при создании слайса на основе уже существующего массива, можно не указывать границы интервала, а таком случае будут браться пограничные значение **включительно,** например:

```Go
arr := [5]int{1, 2, 3, 4, 5}

slc1 := arr[:2]
slc2 := arr[2:]

fmt.Println(slc1) // [1 2]
fmt.Println(slc2) // [3 4 5]
```

Ну и напоследок хочу напомнить, что сравнивать слайсы между собой в Go напрямую нельзя, их можно сравнивать только с **nil**

**Так можно получать слайс, равный nil?**

Ага, например вот так:

```Go
var slc []int = nil

// или

n := nil

slc = n // Может встретиться, если по ошибке где-то присвоишь слайсу значение плохой переменной
```

Не делай так)