---
order: 5
title: Map
---

**Aka** **хэш-таблица, aka хэш-мапа, aka словарь, aka** **ассоциативный массив (как много у него имён)**

Это ещё более сложная структура данных, чем слайсы, так что приготовься.

## Если просто

Мапа в Go ялвляется реализацией хэш-таблиц в ЯП Go.

Хэш-таблица обеспечивает:

-  быстрый доступ к данным за константное время O(1) (ну почти)

-  эффективное использование памяти

-  универсальность (хранение различных типов данных как в качестве ключа, так и значения)

Быстрый доступ в хэш-таблице обеспечивается хэш-функцией, которая вычисляет хэш, оттуда и название (подробнее ниже).

Далее мы с тобой будем постоянно формировать представление мапы в голове, от простого к сложному, так что на протяжении всего чтива она будет менять свой облик, но зато тебе будет легче так воспринимать её.

Для начала держи её объявление (подробнее ещё обсудим):

```Go
m := map[string]int {  
	"Один": 1,
	"Два": 2,
	"Три": 3,    
} 
```

Мапа в Go по сути похожа на массив, где каждый его элемент из себя представляет пару ключ-значение. То есть, итерируясь по мапе, мы будем получать ключ и значение по этому ключу.

Создаём мы мапу, объявляя типы для ключа и значения (то есть типы могут быть любыми допустимыми, но фиксированными для одной мапы) + возможна инициализация при объявлении.

### Типы данных для ключей:

-  **Все числовые типы** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128)

-  **Строки** (string)

-  **Булевы значения** (bool)

-  **Указатели** (\*T)

-  **Интерфейсы** (interface{})

-  **Структуры** (если все поля структуры могут быть сравнены с помощью `==`)

-  **Массивы** (если элементы массива могут быть сравнены с помощью `==`)

### Не могут быть использованы в качестве ключей:

-  **Срезы** (slice)

-  **Карты** (map)

-  **Функции** (func)

Ключи мапы должны быть сравниваемыми типами данных, т.е. которые можно сравнивать с помощью оператора `==`. Это необходимо для обеспечения корректности операций добавления, удаления и поиска элементов в мапе.

### Типы данных для значений map:

Значения в мапе могут быть любого типа, включая:

-  **Все числовые типы** (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128)

-  **Строки** (string)

-  **Булевы значения** (bool)

-  **Указатели** (\*T)

-  **Интерфейсы** (interface{})

-  **Структуры** (struct)

-  **Массивы** (array)

-  **Срезы** (slice)

-  **Карты** (map)

-  **Функции** (func)

-  **Каналы** (chan)

-  **Интерфейсы** (interface{})

### Объявление мапы

```Go
m := map[string]int {      // Объявление с инициализацией
	"Один": 1,
	"Два": 2,
	"Три": 3,              // Обращаю внимание на висящую запятую, без неё синтаксическая ошибка
} 

m := make(map[string]int)      // Объявление пустой мапы, при выводе будет: map[]

m := make(map[string]int, 10)  // Пустая мапа с заданой ёмкостью для оптимизации аллокации памяти

var m map[string]int           // Не инициализированная мапа со значение nil

var m map[string]int{}         // Вызовет синтаксическую ошибку 
// так как объявление с инициализацией требует указания значний как в первом примере
```

После объявления мапы давайте с ней поработаем.

### Работа с мапой

:::danger 

Очень важно помнить, что мапа не является упорядоченной! То есть последовательности в ней не сохраняется, подробнее ниже!

:::

#### Итерация по мапе:

```Go
m := map[string]int {
	"Один": 1,
	"Два": 2,
	"Три": 3,
} 

for key, value := range(m) {
	fmt.Println(key, value)
}
```

#### Добавление или обновление элемента:

```Go
m["Четыре»] = 4
```

#### Удаление элемента:

```Go
delete(m, "четыре")
```

#### Получение значения по ключу:

```Go
value := m["три»] // 3
```

#### Проверка наличия ключа в мапе:

```Go
value, ok := m["три"] // 3, true

value, ok = m["пять"] // 3, false
```

## Если посложнее

Мапа содержит в себе **массив бакетов**.

Бакеты используются для сортировки ключ-значений по определённому признаку (об этом в нижнем разделе) и **хранят в себе до 8 пар ключ-значение**.

То есть такие корзинки для сортировки с восемью ячейками.

Нужно это для более быстрого поиска (разделяй и властвуй).

Но сортировка эта работает не по значению или содержанию ключа, так что и не надейся, **в мапе нет порядка, есть только хаос!)**

Для простоты понимания, давай представлять мапу пока что вот так:

```Go
type bmap struct {
	keys     [8]string  // массив ключей
    values   [8]int     // массив значений
}

type map []bmap // мапа (:
```

То есть массив бакетов, хранящих до 8 ключ-значений.

В нашей схеме это работает так: если при поиске значения мы находим в мапе ключ, совпадающий с указанным, то по id массива `keys` этого ключа, мы достаём элемент из массива `values`

В реальности же Go использует нечто более сложное для представления ключей и значений в бакетах, но для упрощения понимания сойдёт.

### Хэш-функция

Но как мапа позволяет иметь такой быстрый доступ к данным, итерируясь не по индексу, а по ключу? Допустим, у нас в качестве ключа указана строка, сравнивать строки дольше, чем индексы.

Всё верно, но поиск по мапе и производится как раз по индексу. **Всё дело в хэш-функции**

Когда вы добавляете или ищете элемент по ключу (например, строке), хэш-функция (для нас это чёрная коробка, разрабы не раскрывают реализацию) преобразует этот ключ в хэш-значение. Полученное хэш-значение (по сути) делится по модулю, чтобы получить индекс бакета, в который будет помещен элемент.

В найденный бакет ключ-значение попадает в первую свободную ячейку.

:::danger 

Самое главное, что **нет никаких гарантий** того, что элемнет после перезапуска программы снова попадёт в ту же ячейку, что и при первом запуске!

Из-за специфики расчёта индекса бакета, **мапы в Go** **не сохраняют порядок вставки** элементов.

Порядок извлечения элементов из мапы может отличаться от порядка их вставки.

Для каждого запуска программы **используется случайный seed для хэш-функции**, что **рандомизирует распределение**, по сути создавая каждый раз новые хэш-значения для одних и тех же ключей (подробнее ниже), а значит **распределяет их по разным бакетам**, куда они могут попадать в ином порядке.

**Именно поэтому мапа не является упорядоченной!**

:::

### Ради примера создадим мапу с ключом - именем, а значением - возрастом:

![](./map-khesh-tablicy.png)

:::info 

Схема максимально упрощённая. Так, тут опускается структура мапы, строение бакета, вычисление id бакета по маске и т.д., чтобы твой мозг не попросился сразу наружу. Для любителей экзотики вся эта информация будет ниже.

:::

Это работает очень хорошо до момента, пока у нас не будет много ключей. В таком случае хэш-функция не сможет дать всем ключам уникальные хэш-значения.

То есть хэш-функция для  некоторых ключей может вычислить  одинаковые хэш-значения, и произойдёт так называемая **коллизия**.

### Коллизии

Коллизия в общем смысле - это столкновение. В нашем частном случае - столкновение одинаковых значений хэшей.

Для решения коллизий, элемент (ключ-значение) помещается в  overflow бакет, а ссылка на этот overflow бакет сохраняется в исходном бакете.

Такой метод решения коллизий называется метод цепочек (chaining).

В природе существуют и другие методы решения коллизий, помимо метода цепочек, но я не буду заострять на этом внимание, остановимся на том, как это работает в Go.

**Сhaining** справедлив и для переполнения бакета. Когда для нового ключ-значения уже не хватает места в бакете, он отправляется в overflow бакет.

Один бакет может хранить одну ссылку на overflow бакет.

![](./map-khesh-tablicy-2.png)

При этом сам overflow бакет может тоже хранить ссылку на другой overflow бакет в случае коллизий и переполнений, и так далее, жёстких ограничений на стороне реализации Go нет.

Тут и кроется опасность, когда злоумышленник может подобрать входные данные таким образом, чтобы порождать огромное количество коллизий, что может замедлить или даже парализовать работу системы. Но и тут у мапы есть решение, но об этом ниже.

## Если совсем сложно

Подробнее: <https://github.com/golang/go/blob/master/src/runtime/map.go>

#### Небольшое предисловие

По ссылке выше будет актуальная информация реализации map, так как она может незначительно измениться, и ниже может оказаться не актуальная информация.

Подробное строение мапы нужно только ради любопытства (ещё на собесах любят гонять по этой штуке), а для большинства задач хватит понимания того, что метод оптимизации работы с мапой такой же, как и со слайсом - заранее аллоцируем память, если мапа может активно расти, иначе запустится процесс эвакуации, который на некоторое количество операций замедлит работу map + лишняя нагрузка на железо.

Хотя, если обращение к мапе не будет таким частым, то внутренних оптимизаций мапы хватит, и не обязательно выделять заранее конкретное число элементов.

Но если таки интерес берёт верх, то всё же немного приоткроем капот, чтобы понять, как там шестерёнки двигаются.

#### Сразу посмотрим структуру

Сама мапа состоит из 2 структур под названием **header** (hmap) и **bucket** (bmap)

```Go
type hmap struct {
	count     int   
	flags     uint8  
	B         uint8  
	noverflow uint16 
	hash0     uint32 
	buckets    unsafe.Pointer 
	oldbuckets unsafe.Pointer 
	nevacuate  uintptr        
	extra *mapextra
}
```

```Go
type bmap struct {
    tophash  [8]uint8       // массив дополнительных битов хэша для каждой пары ключ-значение
    keys     [8]string      // массив ключей
    values   [8]int         // массив значений
    overflow *bmap          // указатель на overflow бакет
}
```

## Header

### **Count**

Это размер мапы, количество элементов, используется функцией `len()`

### **Flags**

Используются для хранения состояния мапы. Флаги помогают Go-runtime эффективно управлять состоянием мапы, особенно в многопоточных и динамически изменяющихся средах.

Вот как флаги выглядят в официальном гите:

```Go
const (
    iterator      = 1 << iota // 00000001 - мапа в процессе итерации
    oldIterator               // 00000010 - используется старая версия мапы для итерации при росте
    hashWriting               // 00000100 - запись в мапу в процессе
    sameSizeGrow              // 00001000 - мапа растет без изменения числа бакетов
)
```

### B

Это поле заслуживает отдельного подробного разъяснения.

**B** - это **log_2(numBuckets)**, то есть логарифм по основанию 2 от количества бакетов.

Значит 2 в степени B = количество бакетов.

То есть и на самом значении **B** подвязано **количество бакетов**, и наоборот.

Это очень важный для мапы параметр. Он очень удобен для разного рода процессов в мапе. Например, он используется для вычисления индекса путём побитовых операций.

Как описывалось выше, индекс основывается на хэш-значении. А происходит это **при помощи маски**.

**Например:**

Допустим у нас **B = 3**, а значит у нас **8 бакетов**, а хэш-значение предположим такое: **0xA1B2C3D4**

Тогда вычисления будут следующими:

```Go
mask := (1 << B) - 1 // 7
index := hashValue & mask // 4
```

:::note 

**“<<“ –** это битовая операция, которая сдвигает значение слева на количество бит, указанных значением справа, работает это в двоичной системе, в нашем случае процесс выглядит так:

КУРСИВОМ УКАЗАНЫ ЧИСЛА В ДВОИЧНОМ ПРЕДСТАВЛЕНИИ

\*\*mask = (1 << 3) - 1 = (*0001* << 3) - 1 = *1000* - 1 = 8 - 1 = 7 = *0111*

**hashValue = 0xA1B2C3D4 = *1010 0001 1011 0010 1100 0011 1101 0100***

**index = hashValue & mask = *100* = 4**

Побитовое **&** (и) работает по сути как и логическое **&&**: каждая цифра (бит) в соответствующих позициях двух чисел сравнивается, если обе цифры в текущем разряде равны `1`, то в результате для этого разряда будет `1`. Если хотя бы одна цифра в текущем разряде равна `0`, то в результате для этого разряда будет `0`

**1010  0001  1011   0010  1100  0011  1101   0100** (hashValue)

**&**

**0000 0000 0000 0000 0000 0000 0000 0111**  (mask)

---

**0000 0000 0000 0000 0000 0000 0000 0100** (результат = 4)

:::

Все эти расчёты по сути равны тем, что описаны в упрощённой схеме, то есть как бы делим по модулю хэш-значение (в десятичном представлении) на количество бакетов и получаем тот же результат.

Просто **побитовые операции быстрее** классических математических.

И как раз для побитовых операций удобно иметь число, которое является степенью двойки.

Более того, процесс роста мапы обычно её удваивает, а так как **B** является степенью двойки, то мы можем просто прибавлять к **B** единичку, и мапа увеличится вдвое. О процессе роста ниже.

:::note 

1 << N - это наиболее быстрый для процессора аналог возведения двойки в степень N, так как побитовая операция производится за один такт процессора, а математическая - за несколько.

:::

### noverflow

**noverflow** хранит в себе количество overflow бакетов.

Используется для того, чтобы отслеживать количество overflow бакетов и инициировать рост мапы, если количество overflow бакетов становится слишком большим.

**noverflow может хранить в себе как точное, так и приблизительное количество бакетов:**

1. **Точное значение**: Когда количество бакетов невелико (меньше 1<<16 = 65536), `noverflow` хранит точное количество overflow бакетов.

2. **Приблизительное значение**: Когда количество бакетов велико (больше или равно 1<<16), `noverflow` хранит приблизительное количество overflow бакетов. Это сделано для экономии памяти, так как точный подсчет overflow бакетов, при таком их количестве, требует больше ресурсов и времени.

### hash0

**hash0** хранит в себе **seed-значение** для хэш-функции. Он применяется к хэш-значению, что делает индексирование бакетов рандомным.

**Hash0** инициализируется для мапы **рандомным значением** при запуске программы. Поэтому важно понимать следующее: во-первых, **для каждой мапы своё seed-значение**, а во-вторых, после перезапуска программы **элементы будут распределены иначе**, нежели до этого.

Да, именно об этом **seed** я писал выше. Он - одна из главных причин беспорядков в мапе.

Но роль seed очень важна для мап, так как он позволяет распределять данные более равномерно по бакетам, а также это защищает систему от DDOS атак по коллизиям. Как это работает?

Злоумышленник подбирает входные данные так, чтобы создавать множество коллизий, которые будут заставлять мапу использовать память неэффективно, при этом постоянно находясь в процессе роста, что может замедлить или даже парализовать систему.

### buckets

Указатель на массив бакетов мапы. Если поле **count** равно нулю, то **buckets = nil.**

### oldbuckets

Указатель на массив предыдущих бакетов. Используется при росте мапы.

### nevacuate

Количество эвакуированных бакетов, используется в процессе роста мапы, о котором подробнее будем говорить, как всегда, ниже.

### extra

Указатель на структуру **mapextra**, которая выглядит так:

```
type mapextra struct {
	overflow *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```

**overflow** - указатель на массив указателей на overflow бакеты

**oldoverflow** - указатель на массив указателей на overflow бакеты из предыдущей версии этой мапы (как легко догадаться, используется при росте мапы)

**nextOverflow** - указатель на пустой overflow бакет, который затем выделится для решения коллизии, ускоряя этот процесс.

В общем, структура **mapextra** предоставляет вспомогательные поля, которые помогают оптимизировать работу с overflow бакетами, особенно при росте мапы и при частом добавлении новых элементов, обеспечивая более эффективное управление паматью и уменьшение задержек при перераспределении элементов.

## Bucket

Продублирую, как можно представить эту структуру в коде:

```Go
type bmap struct {
    tophash  [8]uint8       // массив дополнительных битов хэша для каждой пары ключ-значение
    keys     [8]string      // массив ключей
    values   [8]int         // массив значений
    overflow *bmap          // указатель на overflow бакет
}
```

А вот для визуалов:

![](./map.png)

На картинке E - дополнительные биты хэша. 

Это и есть массив `tophash`, где его каждый элемент - 8 старших бит хэш-значения ключа.

То есть для `Key0` первые 8 бит его хэш значения будут храниться в `E0` и так далее.

Нужно это для того, чтобы при поиске элемента в мапе не сравнивать сразу значения искомого ключа с теми, что находятся в бакете, что будет занимать достаточно много времени, а для начала посмотреть в массиве, может вообще такого хэша нет, тогда нужно прыгать в overflow бакет по ссылке, чтобы произвести те же проверки там.

Если хэш найден в массиве `tophash`, то дальше по индексу проверяется соответствие искомого ключа с ключом из массива `keys`. Если они совпадают, то искомое значение можно получить из массива `values` по тому же индексу.


