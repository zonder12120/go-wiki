---
order: 8
title: Goрутины и каналы (доделать)
---

## Вступление

Лично мне проще понимать, как что-то использовать, когда я знаю, как это устроено внутри, такой подход позволяет избегать множества не очевидных, но весьма простых ошибок. А так как я тут пишу материал в первую очередь от себя и для себя, то будь по-моему.

Поэтому сначала поглядим на планировщик, а только после этого поковыряем примеры.

Не бойся, я постараюсь как можно нагляднее и проще тебе рассказать про то, как горутинки исполняются в рантайме.

**Стоп!** Тут некоторые могут понимать примерно, что такое рантайм, но не представлять его предметно, хотя это было бы кстати для изучения работы планировщика, ща быстренько исправим.

:::info:true Что такое Runtime, зачем нужен, из чего состоит

## Что такое Runtime?

**Runtime** -- это среда исполнения программы, которая предоставляет необходимые инструменты и сервисы для выполнения программы на компьютере. Рантайм работает во время исполнения скомпилированного кода на процессоре.

### Компоненты Go runtime:

1. **Планировщик (Scheduler)**\
   Управляет выполнением горутин, их созданием, приостановкой и планированием на потоках операционной системы.

2. **Аллокатор памяти (Memory Allocator)**\
   Отвечает за выделение и освобождение памяти для выполнения программ Go.

3. **Сборщик мусора (Garbage Collector, GC)**\
   Автоматически освобождает память, которая больше не используется, обеспечивая эффективное управление памятью.

4. **G (Горутина, Goroutine)**\
   Структура данных, представляющая горутину, содержащая состояние выполнения и стек.

5. **M (Машина, Machine)**\
   Поток ОС, который используется для выполнения горутин.

6. **P (Процессор, Processor)**\
   Виртуальная логическая единица, которая распределяет горутины на исполнение, контролируя их выполнение и помогая рантайму эффективно использовать M-thred’ы для выполнения множества горутин.

   Число P обычно равно числу логических процессоров, доступных для приложения, но оно может быть настроено с использованием функции `runtime.GOMAXPROCS()`.

7. **Локальное хранилище потоков (Thread Local Storage)**\
   **TLS** -- это механизм, позволяющий каждому потоку хранить свои уникальные данные. Эти данные остаются привязанными к потоку,

8. **Netpoller**\
   Управляет асинхронными операциями ввода-вывода, обеспечивая возможность горутинам ожидать сетевых и других событий без блокировки.

### Процессы, управляемые рантаймом:

1. **Управление горутинами (Goroutine Management)**\
   Рантайм управляет созданием, выполнением, приостановкой и возобновлением горутин.

2. **Управление стеком (Stack Management)**\
   Рантайм динамически управляет стеками горутин, расширяя или уменьшая их по мере необходимости.

3. **Обработка сигналов (Signal Handling)**\
   Управляет системными сигналами (например, прерываниями) и их распределением для работы горутин.

4. **Рефлексия в рантайме (Runtime Reflection)**\
   Позволяет программе динамически анализировать и изменять структуры данных и типы во время выполнения программы.

5. **Таймеры (Timers)**\
   Рантайм управляет таймерами для выполнения операций с временными задержками, таких как `time.Sleep` и другие функции, связанные с временем.

6. **Обработка panic и recover**\
   Рантайм управляет механизмами для обработки исключений (panic) и их восстановления (recover), что необходимо для управления ошибками в Go.

7. **Синхронизация (Synchronization)**\
   Рантайм управляет внутренними примитивами синхронизации, такими как мьютексы и каналы.

8. **Механизм трассировки (Tracing Mechanism)**\
   Рантайм предоставляет возможности для трассировки и профилирования выполнения программы.

9. **Управление памятью (Memory Management)**\
   Включает управление выделением и освобождением памяти, а также поддержку различных стратегий управления кэшем и памяти.

10. **Планирование асинхронных задач (Asynchronous Task Scheduling)**\
    Управляет асинхронными задачами, связанными с операциями ввода-вывода и другими долгосрочными задачами.

11. **Детектирование гонок (Race Detection):**

    В режиме разработки доступен механизм, который может обнаруживать состояния гонки при использовании горутин, что помогает в выработке более безопасного параллельного кода.

12. **Автоматическая оптимизация производительности и использования памяти:**

    Рантайм Go выполняет внутренние оптимизации, чтобы улучшать общую производительность программы и минимизировать использование ресурсов.

:::

Сам runtime языка описан здесь: <https://github.com/golang/go/tree/master/src/runtime>

Я где-то могу ошибаться, ты просто добавляй **issue** с указанием ошибки и со ссылкой на **правильный** материал.

## Что такое горутина?

**Горутина** - это абстракция внутри абстракции. *Xzibit* **©**

Сейчас объясню!

![](./goroutines-and-channels-2.png)

Вот есть **поток процессора**. Он вполне себе физический, а не абстрактный, так как предоставляет для исполнения инструкций физические юниты.

Есть **поток ОС** (системный поток), который уже является упаковкой для процесса, такая вот абстракция на уровне ядра ОС, которая может исполняться на потоке процессора (исполняя процесс) и управляется планировщиком ОС.

А есть **горутитна** - легковесный поток, работающий именно внутри рантайма Go, ОС про него ничего не знает, да и горутина не является системным потоком, а всего лишь абстракция на уровне рантайма Go, которая может исполняться на потоке ОС и управляется планировщиком Go. А планировщик Go переключает контекст горутин внутри потока ОС так же, как планировщик ОС переключает контекст потоков ОС внутри потока процессора.

Получается вот такие вот 2 слоя абстракции над потоками процессора.

Горутина исполняется **конкурентно** (**НЕ ПАРАЛЛЕЛЬНО!)**, при этом объявляется горутина ключевым словом `go` перед функцией, но сама горутина – не  функция!

:::note 

Про разницу между параллельностью и конкурентностью я писал в разделе **“База”** в главе **“Операционный системы”**

:::

**Горутина** - это структура, которая содержит в себе необходимые ресурсы для исполнения кода той функции, перед которой поставили  ключевое слово `go`. Состав структуры горутины довольно широкий, в коде его можно посмотреть вот [тут](https://github.com/golang/go/blob/e9a500f47dadcd73c970649a1072d28997617610/src/runtime/runtime2.go), но самое главное, что там есть **адрес первой инструкции функции** и **стек.**

**Почему горутину постоянно называют легковесным потоком?** Всё потому что стек горутины динамический!

**Минимальный** размер стека горутины аж **2 Кб,** а **максимальный** зависит от разрядности системы: до **1 Гб** для 64 разрядных или до **250 Мб** для 32 разрядных. Однако реальное ограничение может быть меньше в зависимости от конфигурации среды исполнения и других факторов

Системные же потоки имеют **фиксированный** размер, для Windows размер стека обычно 1 МБ. В Linux размер стека для потоков, как правило, составляет от 2 до 10 МБ, в зависимости от дистрибутива и настроек ядра.

## Планировщик

Как и говорилось выше в блоке про рантайм, Go scheduler управляет работой горутин в рантайме, поэтому нам важно понимать, как он работает, чтобы эффективно ~~проходить собесы~~ писать конкурентный код.

### Machine

**M (Machine)** -- это системный поток, который выполняет код горутин.

**M** всегда связан с виртуальной структурой **P** (Processor), которая управляет очередью горутин.

### **Processor**

**P** (Processor) в рантайме Go представляет собой **виртуальную логическую единицу** для выполнения горутин. Это один из ключевых компонентов, участвующих в планировании и выполнении горутин. Именно он связывает горутины (**G**) с системными потоками (**M**). Его основная роль заключается в управлении тем, какие горутины будут выполняться на каком системном потоке, и в распределении ресурсов для этих горутин.

**Основной элемент** **P** -- это **локальная очередь** горутин (Local Run Queue), которая содержит горутины, ожидающие выполнения. Далее я её буду называть LRQ.

### LRQ

**LRQ** состоит из двух очередей: **LIFO** и **FIFO**.

:::info:true Что за FIFA?

**Очереди** **( FIFO)** -- «первый пришел и первый ушел» (First in First out). Принцип FIFO означает: сущность, которая первая попала в очередь, первым же отправляется на обработку.

**Стеки (LIFO)** -- «пришел последним, а ушел первым» (Last in First out). В отличие от системы FIFO, стек можно представить в виде стопки тарелок: вы кладете тарелки друг на друга и сначала берете верхние тарелки.

:::

![](./goroutines-and-channels.gif)

Когда горутинка попадает в LRQ, она сначает в LIFO часть очереди, но место там только для одной горутины, поэтому остальные попавшие в очередь горутины вытесняют оттуда первую горутинку и в LIFO остаётся **последняя вошедшая** в LRQ горутина. Остальные попадают в FIFO.  Поэтому из очереди исолняется **сначала последняя вошедшая** горутина, а **затем в порядке очереди**.

**А нужно это вот по какой причине:** довольно большой шанс, что последняя вошедная в очередь горутина уже исполнялась, потом прервалась, а теперь снова попала в очередь. А значит скорее всего данные этой горутинки уже закешированы в процессоре, что даст последней вошедшей горутинке значительно сократить время восстановления контекста и продолжить выполнение с минимальной задержкой, чем если бы она исполнилась в порядке очереди. Это суммарно уменьшает время исполнения всех горутин.

Когда появляется свободный поток (**M**), планировщик Go выбирает одну или несколько горутин из очереди **P** и назначает их для выполнения на этом потоке.

### Процесс работы горутины

![](./goroutines-and-channels.png)

Например, мы создали горутинку, она планировщиком назначается какому-то P и кладётся в его LRQ.