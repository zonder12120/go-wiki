---
order: 3
title: Array
---

Массивы - это самая простая структура данных в Go.

Важно помнить, что сам **массив передаётся по значению**, то есть хранит в себе массив данных.

Поэтому в функцию передаётся по значению, значит в функции будет создана копия массива и функция никакого влияния на оригинальный массив не окажет.

Сам по себе массив представляет из себя последовательность данных с определённым типом, разберём разные способы объявления:

```go
var arr [3]int
// или
arr := [3]int{1, 2, 3}
// или
arr := […]int{1, 2, 3} // В таком случае компилятор сам посчитает количество эл-тов в массиве
```

Причём если мы выведем массив, объявленный первым вариантом, то значения будут инициализированы нулевыми значениеми типа массива:

```go
var arr [3]int

fmt.Println(arr) // [0 0 0]
```

Пришельцам с других языков может показаться странной запись типа данных, а затем следующие за ним фигурные скобки, содержащие элементы этого типа данных. Такое объявление называется **композитным литералом**.

:::info 

**Композитный литерал** -- это запись, состоящая из типа литерала, за которым следует список значений в фигурных скобках. Он создает новый экземпляр указанного типа с инициализацией его значений.

:::

При инициализации массиву сразу выделяется определённое количество памяти, в зависимости от типа данных и его длины.

Поэтому расширить исходный массив не выйдет, придётся создавать новый.

В памяти массив представлен в видел последовательности байт, идущих друг за другом. Каждый элемент массива располагается на то количество байт впереди, сколько занимает 1 элемент типа этого массива, например для `int64` шагом будет 8 байт

```go
const b byte = 1

arr := [...]int64{1, 2, 3, 4}

var addr0 *int64 = &arr[0]

var addr3 *int64 = &arr[3]

// Вычисляем адрес элемента arr[3] с использованием uintptr для арифметики указателей
calcAddr := (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(addr0)) + uintptr(8*b*3)))

fmt.Printf("addr0: %p\n", addr0) //                 addr0: 0x1400001c160
fmt.Printf("addr3: %p\n", addr3) // 				addr3: 0x1400001c178
fmt.Printf("calcAddr: %p\n", calcAddr) // 			calcAddr: 0x1400001c178
fmt.Printf("Value at calcAddr: %d\n", *calcAddr) // Value at calcAddr: 4
```

Прошу обратить внимание, что адрес является не десятичным представлением числа, а **шестнадцатеричным**, поэтому при прибавлении 24 байт к `addr0` у нас получается не 0x1400001c184, а 0x1400001c178.

Мы объявили байт, чтобы получить размер именно в байтах, а не в другом типе данных, иначе арифметика указателей работать не будет. Аналогичным подходом был бы такой вариант:

```go
elementSize := unsafe.Sizeof(arr[0])
calcAddr := (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(addr0)) + uintptr(elementSize*3)))
```