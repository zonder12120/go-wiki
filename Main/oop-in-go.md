---
order: 6
title: ООП в Go
---

В Go нет классического представления ООП, но есть некоторый схожий функционал

## Методы

В Go можно объявлять методы для пользовательских типов данных, определенных в текущем пакете, в том числе и для структур.

### Примеры:

#### Пользовательский тип на основе встроенного типа int:

```
// Объявление типа
type MyInt int

// Объявление метода
func (i MyInt) Add(n MyInt) MyInt {
	return i + n
}

func main() {
	var num MyInt = 1

	fmt.Println(num.Add(1)) // 2
}
```

#### Структура:

```
// Структура
type Person struct {
	Name  string
	Age uint8
}

// Метод структуры Person
// Использование указателя для передачи структуры, чтобы можно было изменить значение поля Age
func (p *Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

В примере со структурой видно, что структуру в метод мы передаём по указателю, чтобы иметь доступ к оригинальному экземпляру ~~класса~~ коллекции.

Представим, что мы не использовали бы указатель. В таком случае, вызов метода из созданного экземпляра структуры создаст копию этого экземпляра, и если метод реализует изменение поля этой структуры, то это изменение применится к копии. 

Проверим это:

```Go
type Person struct {
	Name  string
	Age uint8
}

// Передаём структуру в метод по значению
func (p Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya = danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

Если бы мы не переопределили значение переменной danya, то на выводе у нас было бы число 26, а строчка с вызовом метода была бы подчёркнута как некорректная.

В общем, передача структуры по указателю позволяет управлять исходным экземпляром + снижает нагрузку на память, так как не передаётся полная копия всей структуры, а всего лишь адрес весом 8 байт в 64 битной системе или 4 байта в 32 битной.

## Композиция/встраивание (наследование)

Аналог наследованная из классического ООП.

**Композиция** - это возможность встроить однин структурный тип в другой с наследованием методов и полей.

Давайте на более ёмком примере разберём подходы к инициализации вложенных структур.

Создадим структуры Animal, Pet (наслледник Animal) и Cat (наследник Pet), заодно реализуем enum для поля Gender.

Рекомендую копировать примеры в IDE и пощупать, как это всё работает.

### Вариант 1. Без боли

```
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Animal struct {
	WeightKg float32
	SpeedKmH uint8
}

func (a *Animal) Say(sound string) string {
	fmt.Println(sound)
	return sound
}

type Pet struct {
	Animal
	Name   string
	Age    float32
	Gender Gender
}

type Cat struct {
	Pet
	Breed string
}

func main() {
	var asya Cat

	asya.WeightKg = 3.5
	asya.SpeedKmH = 8
	asya.Name = "Ася"
	asya.Age = 0.5
	asya.Gender = Female
	asya.Breed = "бенгал"

	fmt.Println(asya) // {{{3.5 8} Ася 0.5 самка} бенгал}

	asya.Say("Мяу»)
}
```

В этом варианте мы инициализировали поля, через прямое обращение к ним. При этом при встраивании структур просто указали их тип. Но есть вариант и создать поле с типом наследуемой структуры, чтобы явно взаимодействовать с наследуемыми полями и методами, например:

```
...Остальной код...

type Pet struct {
	Animal Animal
	Name   string
	Age    float32
	Gender Gender
}

type Cat struct {
	Pet Pet
	Breed string
}

func main() {
	var asya Cat

	asya.Pet.Animal.WeightKg = 3.5
	asya.Pet.Animal.SpeedKmH = 8

	fmt.Println(asya) // {{{3.5 8} Ася 0.5 самка} бенгал}

	asya.Pet.Animal.Say("Мяу»)
}
```

Строгих правил использования нет, зависит от ситуации.

Но вот есть ещё вариант инициализации структур с наследованием.

### Вариант 2. С болью

```Go
package main

import (
	"fmt"
)

type Gender int

const (
	Male Gender = iota + 1
	Female
)

func (s Gender) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Animal struct {
	WeightKg float32
	SpeedKmH uint8
}

func (a *Animal) Say(sound string) string {
	fmt.Println(sound)
	return sound
}

type Pet struct {
	Animal Animal // Наследуемся через указатель
	Name   string
	Age    float32
	Gender Gender
}

type Cat struct {
	Pet   Pet
	Breed string
}

func main() {
	asya := Cat{
		Pet: Pet{
			Animal: Animal{
				WeightKg: 3.5,
				SpeedKmH: 8,
			},
			Name:   "Ася",
			Age:    0.6,
			Gender: Female,
		},
		Breed: "бенгал",
	}

	fmt.Println(asya.Pet.Gender)
	fmt.Println(asya.Breed)

	asya.Pet.Animal.Say("мяу")
}
```

:::note 

Хочу обратить внимание на то, что **при наследовании структуры,** **создаётся её экземпляр**. 

А доступ к полям и методам этого экземпляра есть **напрямую из наследника**, поэтому передавать наследуемые структуры по указателю нет смысла.

:::

### Подытожим

В нашем примере мы создали **экземпляр структуры Cat**, которая является **наследником структуры Pet**, которая в свою очередь является **наследником структуры Animal**.

### Передача структуры по значению или по указателю?

Когда мы передаём структуру по значению, мы создаём копию, что, разумеется, создаёт некоторые накладные расходы на память. Но важно понимать, когда использовать указатели, а когда - оно того не стоит.

Из раздела “База”, статьи про процессора, мы знаем, что кэш делится на кэш-линии, длиной по 64 байта.

И обычно принято ориентироваться на то, что если структура весит <= 64 байт, то нет смысла использовать указатели для передачи структуры, процесс копирования и так будет очень быстрым.

А вот если > 64 байт…  

Да в целом это холивар, здесь все по-своему на это смотрят: <https://habr.com/ru/companies/it-guide/articles/744046/>

Но вот немного слов ЗА и ПРОТИВ:

Если метод **не должен изменять структуру** (например, он только читает данные), можно передавать структуру **по значению**. Это помогает защитить данные от нежелательных изменений.

Передача по значению может упростить код, избегая проверок на nil.

#### **Типичная практика**:

-  Для структур размером до 2-3 кэш-линий (т.е. до 128-192 байт) передача по значению обычно приемлема.

-  Для структур размером больше 3 кэш-линий (более 192 байт) предпочтительнее передавать по указателю.

#### Примерные размеры

-  **Маленькие структуры** (до 64 байт): могут включать несколько примитивных полей, таких как `int`, `float64`, `bool`, и могут быть переданы по значению без значительных накладных расходов.

-  **Средние структуры** (64-192 байт): структуры, включающие несколько массивов или строк, и могут быть переданы по значению в зависимости от контекста и использования.

-  **Большие структуры** (более 192 байт): структуры, содержащие большие массивы, срезы или множество полей, чаще передаются по указателю для улучшения производительности.

#### **Консистентность**:

Важно придерживаться единого стиля на протяжении всего проекта. Если принято во всём проекте передавать структуру по указателю, то необходимо придерживаться этого решения, учитывая все накладные расходы при разработке (например проверки на nil).