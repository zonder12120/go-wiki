---
order: 6
title: ООП в Go
---

В Go нет классического представления ООП, но есть некоторый схожий функционал

## Методы

В Go можно объявлять методы для пользовательских типов данных, определенных в текущем пакете, в том числе и для структур.

### Примеры:

#### Пользовательский тип на основе встроенного типа int:

```
// Объявление типа
type MyInt int

// Объявление метода
func (i MyInt) Add(n MyInt) MyInt {
	return i + n
}

func main() {
	var num MyInt = 1

	fmt.Println(num.Add(1)) // 2
}
```

#### Структура:

```
// Структура
type Person struct {
	Name  string
	Age uint8
}

// Метод структуры Person
// Использование указателя для передачи структуры, чтобы можно было изменить значение поля Age
func (p *Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

В примере со структурой видно, что структуру в метод мы передаём по указателю. Представим, что мы не использовали бы указатель. В таком случае вызов метода из созданного экземпляра ~~класса~~ структуры создаст копию этого экземпляра, и если метод реализует изменение поля этой структуры, то это изменение применится к копии. 

Проверим это:

```Go
type Person struct {
	Name  string
	Age uint8
}

// Передаём структуру в метод по значению
func (p Person) growUp(y uint8) {
	p.Age += y
}

func main() {
	danya := Person{"Даня", 26}

	danya = danya.growUp(1)

	fmt.Println(danya.Age) // 27
}
```

Если бы мы не переопределили значение переменной danya, то на выводе у нас было бы число 26, а строчка с вызовом метода была бы подчёркнута как некорректная.

## Композиция/встраивание

Аналог наследованная из классического ООП.

**Композиция** - это возможность встроить однин структурный тип в другой с наследованием методов и полей.

В Go инициализация вложенных структур должна выполняться через явное указание полей структуры.

```Go
package main

import (
	"fmt"
)

type Sex int

const (
	Male Sex = iota + 1
	Female
)

func (s Sex) String() string {
	switch s {
	case Male:
		return "самец"
	case Female:
		return "самка"
	}
	return "ошибка"
}

type Animal struct {
	WeightKg float32
	SpeedKmH uint8
}

type Pet struct {
	Animal *Animal // Наследуемся через указатель
	Name   string
	Age    float32
	Gender Sex
}

type Cat struct {
	Pet   *Pet
	Breed string
}

func (a *Animal) Say(sound string) string {
	fmt.Println(sound)
	return sound
}

func main() {
	asya := &Cat{
		Pet: &Pet{
			Animal: &Animal{
				WeightKg: 3.5,
				SpeedKmH: 8,
			},
			Name:   "Ася",
			Age:    0.6,
			Gender: Female,
		},
		Breed: "бенгал",
	}

	fmt.Println(asya.Pet.Gender)
	fmt.Println(asya.Breed)

	asya.Pet.Animal.Say("мяу")
}
```

Рекомендую копировать пример в IDE и пощупать, как это всё работает.

В нашем примере мы создали **экземпляр структуры Cat**, которая является **наследником структуры Pet**, которая в свою очередь является **наследником структуры Animal**.

В этом примере мы передаём структуры **по указателям**. На самом деле для наших структур это не обязательно, но сделал я это для того, чтобы наглядно показать, как это пишется.

Теперь давай обсудим, когда нужен указатель, а когда нет.

### Передача структуры по значению или по указателю?

Когда мы передаём структуру по значению, мы создаём копию, что, разумеется, создаёт некоторые накладные расходы на память. Но важно понимать, когда использовать указатели, а когда - оно того не стоит.

Из раздела “База”, статьи про процессора, мы знаем, что кэш делится на кэш-линии, длиной по 64 байта