---
order: 2
title: Указатели
---

**Указатель** - это переменная, которая хранит в себе адрес другой переменной.

Объем памяти, занимаемый переменной-указателем, является фиксированным значением, независимо от размера значения, на которое она указывает. На 32-битной машине переменная-указатель занимает **4 байта**, а на 64-битной -- **8 байт**.

При объявлении указателя используется звёздочка “**\***” (астерикс).

Амперсанд “**&**“ - оператор взятия адреса. Эта операция также называется **выборкой адреса.**

```go
num := 1
ptr := &num // Короткая запись, которая опускает тип, но тип важен, про него ниже
```

Надеюсь, тебе очевидно, что **адрес переменной - это адрес первой ячейки в адресном пространстве программы**, в которой хранится переменная.

:::note 

Напоминаю информацию из раздела “База”.

Когда программа запускается, операционная система создает для нее отдельное **виртуальное адресное пространство**.

Адреса в виртуальном адресном пространстве **не соответствуют физическим адресам** в оперативной памяти.

:::

Из раздела “База” мы знаем, что 1 ячейка памяти = 1 байт.

Если переменная занимает больше одной ячейки (больше одного байта), то остальные ячейки относятся к переменной за счёт длины переменной.

Допустим, указатель на переменную типа int32 (4 байта) показывает на адрес `0x00000004`, значит адреса `0×00000005`, `0×00000006`, `0×00000007 `тоже относятся к этой переменной.

Может возникнуть вопрос, а как тогда компилятор понимает, сколько соседних ячеек зарезервировано для нашей переменной при использовании только одного указателя?

Для этого у указателя задаётся **тип указателя (и явно, и не явно)**, соответствующий типу переменной, на которую он указывает. На пример `*int` - указатель на переменную типа `int`

Нам эта информация очень важна при получении значения по адресу из указателя, чтобы знать, сколько ячеек отнести к значению переменной, опираясь на первый байт, который записан в наш указатель.

Этот процесс называется **разыменовыванием**.

Чтобы разыменовать указатель, надо перед ним поставить астерикс “\*”

Настало время примеров:

```go
way := "north" // Переменная типа string

// Записали в указатель ptr с типом *string адрес значения переменной way
var ptr *string = &way 

// Разыменование
fmt.Println(*ptr) // north
```

При этом указатель может быть равен `nil`, что может создавать трудности при работе с указателями.

```go
var ptr *int // не инициализированный указатель будет равен nil

fmt.Println(ptr) // <nil>
```

Часто в Go вместо передачи по значению, для избежания копирования больших данных, используют указатели, так как они занимают всего либо 4, либо 8 байт, в зависимости от разрядности.

И в таком случае есть риск передать указатель равный `nil`, что при разыменовании обязательно вызовет **панику.**

Причём `nil` может быть в указателе как по ошибке программиста (например не инициализировал указатель), так и в ходе работы сборщика мусора, когда область памяти, на которую указывает указатель, сборщик по той или иной причине освободил, ну и так далее.

Чтобы избежать проблем при работе с указателем, требуется его проверять на `nil`.

```go
func printValue(p *int) {
    if p != nil {
        fmt.Println(*p)
    } else {
        fmt.Println("Указатель равен nil")
    }
}
```

Указатели хранятся в куче, поэтому слишком большое количество указателей могут сильно нагружать сборщик мусора, что влечёт за собой серьёзное снижение производительности.

**Ну и запомни важные вещи:**

1. Не надо использовать указатели для ссылочных типов

2. Нет необходимости использовать указатели для базовых типов данных

3. Не стоит использовать вложенные указатели (пример ниже)

```go
// Использование указателей на указатели может усложнить понимание и сопровождение кода!
var x int
var p *int = &x
var pp **int = &p
fmt.Println(**pp)
```

Ну и для фанатов C есть плохие новости, арифметики указателей (адресной арифметики) в Go нет, плак-плак :((((

:::danger 

**В Go нет ссылок в классическом смысле**, как, например, в языке C++. (см. гугол)

Однако указатели в Go выполняют аналогичную функцию, позволяя передавать адреса переменных. Когда ты передаёшь указатель, вы передаёте адрес, по которому можно получить доступ к данным, хранящимся в другой переменной. Это позволяет изменять эти данные без создания копий.

Таким образом, через указатели фактически передаются адреса, что функционально похоже на использование ссылок в других языках программирования.

НО ЧТОБЫ ДОБИТЬ ТЕБЯ

В Go **корректно** называть **slice**, **map**, **channel** и **interface**, не передающиеся по значению ССЫЛОЧНЫМИ.

Хотя более корректным было бы их называть УКАЗАТЕЛЬНЫМИ ТИПАМИ (:

:::