---
order: 10
title: HTTP (доделать)
---

## База

Подробную базу по **HTTP** мне тут описывать тупо лень, потому что там по сути ничего сложного нет, просто стоит почитать про модель **OSI** немного, про то, как работает **TCP**, а затем про реализацию **HTTP.**

У разного рода онлайн школ есть вполне себе ёмкие статейки. Рекомендую по несколько раз почитать про каждую тему.

Отдельно глянь, что такое заголовки и зачем они нужны.

Как всё изучишь, приходи снова сюда.

В Go стандартная библиотека предоставляет пакет `net/http`, который позволяет работать с протоколом **HTTP.**

Обычно у нас такая модель: сервер и клиент.

Клиент кидает запрос, а сервер по этому запросу даёт ответ.

Разберёмся сначала с клиентом.

## Клиент

Основной компонент, отвечающий за отправку HTTP-запросов в Go, -- это `http.Client`.

`http.Client` -- это структура, которая отвечает за выполнение HTTP-запросов. Вот как она выглядит в исходном коде:

```go
type Client struct {
    Transport RoundTripper // Интерфейс для отправки HTTP-запросов
    CheckRedirect func(req *Request, via []*Request) error // Обработчик редиректов
    Jar CookieJar // Cookie storage
    Timeout time.Duration // Время ожидания выполнения запроса
}
```

#### Поля структуры `http.Client`:

1. **Transport**:\
   Поле `Transport` реализует интерфейс `RoundTripper`, который определяет, как именно запрос отправляется и как обрабатывается ответ. По умолчанию используется `http.DefaultTransport`, которое управляет установлением TCP-соединений, повторными попытками в случае неудачи и пулами соединений.

   Например, если вам нужно настроить прокси или задать специальные таймауты для подключений, вы можете настроить свой собственный `Transport`:

   ```go
   tr := &http.Transport{
       Proxy: http.ProxyFromEnvironment,
       MaxIdleConns: 10,
       IdleConnTimeout: 30 * time.Second,
   }
   client := &http.Client{Transport: tr}
   ```

2. **CheckRedirect**:\
   Это функция, которую можно использовать для управления поведением при редиректах (когда сервер возвращает статус 3xx). По умолчанию клиент следует по юрлу, который указан в редиректе сервера. Если вам нужно настроить количество попыток перенаправления или игнорировать их, вы можете задать свою логику.

   Пример:

   ```go
   client := &http.Client{
       CheckRedirect: func(req *http.Request, via []*http.Request) error {
           if len(via) >= 10 {
               return errors.New("стандартный лимит редиректов превышен")
           }
           return nil
       },
   }
   ```

3. **Jar**:\
   `Jar` -- это интерфейс для управления cookie. Если вам нужно сохранять и отправлять cookie между запросами, вы можете использовать это поле. `http.Client` по умолчанию не сохраняет cookie между запросами, но вы можете настроить клиент для работы с `CookieJar`.

4. **Timeout**:\
   Поле `Timeout` задает максимальное время выполнения запроса. Если запрос не будет завершен за отведенное время, клиент прервет его выполнение и вернет ошибку.

   Пример установки таймаута:

   ```go
   client := &http.Client{
       Timeout: 10 * time.Second,
   }
   ```

### Основные методы и их назначение

Например, мы используем дефолтный клиент, чтобы не создавать новый:

```go
client := http.DefaultClient
```

`http.Client` предоставляет несколько ключевых методов для работы с HTTP-запросами:

-  **Get**:\
   Отправляет HTTP-запрос типа GET для получения данных с указанного URL.

```go
resp, err := client.Get("https://example.com")
```

-  **Post**:\
   Отправляет HTTP-запрос типа POST для передачи данных. Часто используется для отправки форм с фронта.

```go
resp, err := client.Post("https://example.com", "application/json", bytes.NewBuffer(jsonData))
```

Где `application/json` это значение поля заголовка `Content-Type`, который, как не сложно, определяет тип контента, передаваемого в теле запроса.

-  **Do**:\
   Этот метод является самым общим и позволяет отправлять любые виды HTTP-запросов, включая запросы с методами **PATCH**, **PUT** и **DELETE**. Вы сами создаете объект `http.Request` и передаете его клиенту.

   Пример отправки запроса с кастомными заголовками:

```go
req, err := http.NewRequest("GET", "https://example.com", nil)
if err != nil {
    log.Fatal(err)
}
req.Header.Set("User-Agent", "my-client")

client := &http.Client{}
resp, err := client.Do(req)
```

### Ответ

После выполнения запроса, нам приходит ответ. В ответе тоже есть заголовки, а также **Body**.

**Body** всегда будет в ответе, даже если он нулевой длины. Когда сервер отправляет ответ с нулевым телом, это просто означает, что тело пусто, но объект `Body` будет всё равно присутствовать в структуре `http.Response`.

Тело содержит последовательность байтов, которое нужно будет привести к типу, указанному в `Content-Type`.

**Закрытие** `resp.Body` необходимо, чтобы сигнализировать клиенту, что все данные были прочитаны, и соединение можно безопасно вернуть в пул. Если тело не закрыть, соединение не будет возвращено, что может привести к исчерпанию доступных соединений (особенно при большом количестве запросов) и утечкам ресурсов. Это также может вызвать ошибку "too many open files" на высоких нагрузках.

Пул соединений на клиенте позволяет избежать затрат на создание новых TCP-соединений для каждого нового запроса. Это оптимизирует работу HTTP-клиента и уменьшает задержки при отправке последующих запросов к тому же серверу.

На стороне сервера соединение **не обязательно закрывается**. Если сервер поддерживает `Keep-Alive`, то он также может оставить соединение открытым для того, чтобы его можно было использовать для следующих запросов. В этом случае сервер будет ожидать новых запросов от клиента по этому же соединению.

Однако, если сервер решает закрыть соединение (например, из-за высокой нагрузки или отсутствия необходимости в поддержке соединения), он может отправить заголовок `Connection: close` в ответе. Это указывает клиенту, что соединение нужно закрыть и больше не использовать.

Пример использования реального API с выводом реального ответа:

```go
func main() {
	client := http.DefaultClient
	
	// Кидаем запрос, записываем ответ в resp
	resp, err := client.Get("https://randomuser.me/api/")
	if err != nil {
		log.Fatalf("Ошибка отправки запроса: %v", err)
	}
	
	// Закрываем Body по окончании функции (НЕ ЗАБЫВАЕМ ЭТО ДЕЛАТЬ!)
	defer resp.Body.Close()
	
	// Проверка кода статуса ответа, если не 200, то ошибка. 
	//Для этого используем константу кода ответа
	if resp.StatusCode != http.StatusOK { 
		log.Fatalf("Ошибка: сервер вернул статус %v", resp.Status)
	}
	
	// Выводим все хэдеры
	for name, headers := range resp.Header {
		for _, h := range headers {
			fmt.Printf("%v: %v\n", name, h)
		}
	}
	
	// Проверяем Content-Type, чтобы обязательно был json
	contentType := resp.Header.Get("Content-Type")
	if contentType != "application/json" {
		log.Fatalf("Неожиданный тип контента: %s", contentType)
	}
	
	// Выводим статус в виде кода, а затем целиком
	fmt.Printf("Статус запроса: %v, %v\n", resp.StatusCode, resp.Status)

	// Читаем весь Body разом, записываем его в переменную body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Ошибка чтения тела ответа: %v", err)
	}
	
	// Приводим body к строке и выводим
	fmt.Println(string(body))
}
```


