---
order: 10
title: HTTP (доделать)
---

## База

Подробную базу по **HTTP** мне тут описывать тупо лень, потому что там по сути ничего сложного нет, просто стоит почитать про модель **OSI** немного, про то, как работает **TCP**, а затем про реализацию **HTTP.**

У разного рода онлайн школ есть вполне себе ёмкие статейки. Рекомендую по несколько раз почитать про каждую тему.

Отдельно глянь, что такое заголовки и зачем они нужны.

Как всё изучишь, приходи снова сюда.

В Go стандартная библиотека предоставляет пакет `net/http`, который позволяет работать с протоколом **HTTP.**

Обычно у нас такая модель: сервер и клиент.

Клиент кидает запрос, а сервер по этому запросу даёт ответ.

Разберёмся сначала с клиентом.

## Клиент

Основной компонент, отвечающий за отправку HTTP-запросов в Go, -- это `http.Client`.

`http.Client` -- это структура, которая отвечает за выполнение HTTP-запросов. Вот как она выглядит в исходном коде:

```go
type Client struct {
    Transport RoundTripper // Интерфейс для отправки HTTP-запросов
    CheckRedirect func(req *Request, via []*Request) error // Обработчик редиректов
    Jar CookieJar // Cookie storage
    Timeout time.Duration // Время ожидания выполнения запроса
}
```

#### Поля структуры `http.Client`:

1. **Transport**:\
   Поле `Transport` реализует интерфейс `RoundTripper`, который определяет, как именно запрос отправляется и как обрабатывается ответ. По умолчанию используется `http.DefaultTransport`, которое управляет установлением TCP-соединений, повторными попытками в случае неудачи и пулами соединений.

   Например, если вам нужно настроить прокси или задать специальные таймауты для подключений, вы можете настроить свой собственный `Transport`:

   ```go
   tr := &http.Transport{
       Proxy: http.ProxyFromEnvironment,
       MaxIdleConns: 10,
       IdleConnTimeout: 30 * time.Second,
   }
   client := &http.Client{Transport: tr}
   ```

2. **CheckRedirect**:\
   Это функция, которую можно использовать для управления поведением при редиректах (когда сервер возвращает статус 3xx). По умолчанию клиент следует по юрлу, который указан в редиректе сервера. Если вам нужно настроить количество попыток перенаправления или игнорировать их, вы можете задать свою логику.

   Пример:

   ```go
   client := &http.Client{
       CheckRedirect: func(req *http.Request, via []*http.Request) error {
           if len(via) >= 10 {
               return errors.New("стандартный лимит редиректов превышен")
           }
           return nil
       },
   }
   ```

3. **Jar**:\
   `Jar` -- это интерфейс для управления cookie. Если вам нужно сохранять и отправлять cookie между запросами, вы можете использовать это поле. `http.Client` по умолчанию не сохраняет cookie между запросами, но вы можете настроить клиент для работы с `CookieJar`.

4. **Timeout**:\
   Поле `Timeout` задает максимальное время выполнения запроса. Если запрос не будет завершен за отведенное время, клиент прервет его выполнение и вернет ошибку.

   Пример установки таймаута:

   ```go
   client := &http.Client{
       Timeout: 10 * time.Second,
   }
   ```

### Основные методы и их назначение

Например, мы используем дефолтный клиент, чтобы не создавать новый:

```go
client := http.DefaultClient
```

`http.Client` предоставляет несколько ключевых методов для работы с HTTP-запросами:

-  **Get**:\
   Отправляет HTTP-запрос типа GET для получения данных с указанного URL.

```go
resp, err := client.Get("https://example.com")
```

-  **Post**:\
   Отправляет HTTP-запрос типа POST для передачи данных. Часто используется для отправки форм с фронта.

```go
resp, err := client.Post("https://example.com", "application/json", bytes.NewBuffer(jsonData))
```

Где `application/json` это значение поля заголовка `Content-Type`, который, как не сложно, определяет тип контента, передаваемого в теле запроса.

-  **Do**:\
   Этот метод является самым общим и позволяет отправлять любые виды HTTP-запросов, включая запросы с методами **PATCH**, **PUT** и **DELETE**. Вы сами создаете объект `http.Request` и передаете его клиенту.

   Пример отправки запроса с кастомными заголовками:

```go
req, err := http.NewRequest("GET", "https://example.com", nil)
if err != nil {
    log.Fatal(err)
}
req.Header.Set("User-Agent", "my-client")

client := &http.Client{}
resp, err := client.Do(req)
```

### Ответ

После выполнения запроса, нам приходит ответ. В ответе тоже есть заголовки, а также **Body**.

**Body** всегда будет в ответе, даже если он нулевой длины. Когда сервер отправляет ответ с нулевым телом, это просто означает, что тело пусто, но объект `Body` будет всё равно присутствовать в структуре `http.Response`.

Тело содержит последовательность байтов, которое нужно будет привести к типу, указанному в `Content-Type`.

**Закрытие** `resp.Body` необходимо, чтобы сигнализировать клиенту, что все данные были прочитаны, и соединение можно безопасно вернуть в пул. Если тело не закрыть, соединение не будет возвращено, что может привести к исчерпанию доступных соединений (особенно при большом количестве запросов) и утечкам ресурсов. Это также может вызвать ошибку "too many open files" на высоких нагрузках.

Пул соединений на клиенте позволяет избежать затрат на создание новых TCP-соединений для каждого нового запроса. Это оптимизирует работу HTTP-клиента и уменьшает задержки при отправке последующих запросов к тому же серверу.

На стороне сервера соединение **не обязательно закрывается**. Если сервер поддерживает `Keep-Alive`, то он также может оставить соединение открытым для того, чтобы его можно было использовать для следующих запросов. В этом случае сервер будет ожидать новых запросов от клиента по этому же соединению.

Однако, если сервер решает закрыть соединение (например, из-за высокой нагрузки или отсутствия необходимости в поддержке соединения), он может отправить заголовок `Connection: close` в ответе. Это указывает клиенту, что соединение нужно закрыть и больше не использовать.

Пример использования реального API с выводом реального ответа:

```go
func main() {
	client := http.DefaultClient
	
	// Кидаем запрос, записываем ответ в resp
	resp, err := client.Get("https://randomuser.me/api/")
	if err != nil {
		log.Fatalf("Ошибка отправки запроса: %v", err)
	}
	
	// Закрываем Body по окончании функции (НЕ ЗАБЫВАЕМ ЭТО ДЕЛАТЬ!)
	defer resp.Body.Close()
	
	// Проверка кода статуса ответа, если не 200, то ошибка. 
	//Для этого используем константу кода ответа
	if resp.StatusCode != http.StatusOK { 
		log.Fatalf("Ошибка: сервер вернул статус %v", resp.Status)
	}
	
	// Выводим все хэдеры
	for name, headers := range resp.Header {
		for _, h := range headers {
			fmt.Printf("%v: %v\n", name, h)
		}
	}
	
	// Проверяем Content-Type, чтобы обязательно был json
	contentType := resp.Header.Get("Content-Type")
	if contentType != "application/json" {
		log.Fatalf("Неожиданный тип контента: %s", contentType)
	}
	
	// Выводим статус в виде кода, а затем целиком
	fmt.Printf("Статус запроса: %v, %v\n", resp.StatusCode, resp.Status)

	// Читаем весь Body разом, записываем его в переменную body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Ошибка чтения тела ответа: %v", err)
	}
	
	// Приводим body к строке и выводим
	fmt.Println(string(body))
}
```

## Сервер

### Эндпоинты

На сервере вообще всё очень просто. У нас есть адрес, по которому мы обращаемся к серверу – наш юрл как раз. А там запросы сервер может обрабатывать разные, но чтобы их различать, для запросов нужны адреса. Так называемые эндпоинты, ну или же “ручки”, за которые как раз клиент и “дёргает”. Обычно они находятся в конце юрла. В наше примере с клиентом был такой юрл:

```
https://randomuser.me/api/
```

Где `/api` в конце как раз и есть эндпоинт/ручка

Но этот эндпоинт нужно привязать как-то к функции, которая будет по нему работать. Для этого нужен **обработчик – handler.**

Например**:**

```
http.HandleFunc("/example", example)
```

Тут мы привязываем эндпоинт `/example` к одноимённой функции `example` с помощью функции `HandleFunc()` из пакета `http`.

Функция `HandleFunc()` принимает эндпоинти функцию с сигнатурой `func(ResponseWriter, *Request)`

#### Пройдёмся как раз по этой функции-обработчику:

`http.ResponseWriter` позволяет обработчику формировать ответ клиенту, отправив его через HTTP. Это интерфейс, который предоставляет методы для записи данных в тело ответа и установки HTTP-заголовков.

Основные методы:

-  **Write(\[\]byte)**: Записывает данные в тело ответа.

-  **Header()**: Возвращает заголовки ответа.

-  **WriteHeader(statusCode int)**: Устанавливает HTTP-статус ответа (например, `200 OK`, `404 Not Found`).

Использование указателя (`*Request`) позволяет передавать не копию структуры, а ссылку на один и тот же объект. Это делает работу с запросом эффективной по памяти, особенно для больших структур, таких как тело запроса. Кроме того, позволяет изменять содержимое запроса, если это необходимо для обработки.

 	

### Здесь и у серверов есть уши

Сервер умеет слушать. Слушает он порт.

**Порт** -- это 16-битное целое число (от 0 до 65535), которое используется для различения различных сетевых служб или процессов на одной машине. Порт служит "входной точкой" для сетевого взаимодействия.

Каждый процесс, который хочет принимать сетевые соединения (например, веб-сервер), "прослушивает" конкретный порт. Это позволяет операционной системе направлять входящие данные к правильному процессу.

Когда процесс запускается и начинает "слушать" порт, операционная система резервирует этот порт для данного процесса. Это означает, что только этот процесс может принимать данные через этот порт.

#### http.ListenAndServe()

Чтобы сервер начал “слушать” порт, нужно запустить функцию `http.ListenAndServe()`

Первый аргумент функции заполняется строкой по форме "host:port"

Если поставить пустую строку, сервер будет слушать на порте 80 на всех интерфейсах и его можно будет достичь через любые доступные IP-адреса сервера, например: 

-  localhost:80 

-  127\.0.0.1:80 

-  адрес машины, доступный из сети

Функция `http.ListenAndServe` во втором аргументе принимает объект, реализующий интерфейс `http.Handler`. Этот интерфейс имеет всего один метод:

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

После запуска функции `http.ListenAndServe()` под капотом запускается бесконечный цикл, который принимает в себя новые коннекшены по порту и конкурентно в горутинах обрабатывает их заданными функциями.

Бесконечный цикл можно остановить несколькими способами:

-  **Прерывание программы вручную** (например, `Ctrl+C` в терминале).

-  **Возникновение критической ошибки** (например, если порт недоступен или произошёл сбой при создании сокета).

-  **Остановка сервера** программно, например через сигнал или вызов метода `Shutdown` у `http.Server`.

Как это выглядит в коде?

Давай напишем свой сервер, который будет передавать в ответет текст “Hello”

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

// Функция обработчик
func hello(w http.ResponseWriter, req *http.Request) {
	// Fptintf сам записывает в тело ответа байтики как надо, дёргая метод Write у ResponseWriter
	fmt.Fprintf(w, "hello\n")
}

func HTTPServer() {

	// Функция HandleFunc принимает строку и функцию с сигнатурой func(ResponseWriter, *Request)
	http.HandleFunc("/hello", hello)

	
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatalf("Ошибка заппуска сервера на порте 8080: %v", err)
	}
}

func main() {
	HTTPServer()
}
```

### Зачем нужен второй аргумент в функции `http.ListenAndServe()`?

Второй аргумент функции позволяет указать, какой обработчик будет обрабатывать все входящие HTTP-запросы. Это может быть:

-  Логика маршрутизации запросов.

-  Предварительная обработка данных.

-  Поддержка middleware (например, логирование или аутентификация).

Если передать `nil`, сервер будет использовать глобальный маршрутизатор, и все обработчики, зарегистрированные через `http.HandleFunc`, будут автоматически подключены.

#### Примеры использования

1\. **Использование** `nil` (по умолчанию `http.DefaultServeMux`)

Если передать `nil`, сервер будет использовать глобальный маршрутизатор, и все обработчики, зарегистрированные через `http.HandleFunc`, будут автоматически подключены.

Пример есть выше

#### 2\. **Использование кастомного обработчика**

Ты можешь передать объект, реализующий интерфейс `http.Handler`, чтобы полностью контролировать обработку запросов. 

Пример кастомного обработчика:

```go
package main

import (
    "fmt"
    "net/http"
)

// Определение обработчика, реализующего интерфейс http.Handler
type myHandler struct{}

func (h *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, "This is a custom handler")
}

func main() {
    handler := &myHandler{}
    // Используем кастомный обработчик
    http.ListenAndServe(":8080", handler)
}
```

#### 3\. **Использование** `http.ServeMux` для маршрутизации

`http.ServeMux` -- это встроенный маршрутизатор, который можно использовать для более гибкой маршрутизации запросов.

Пример:

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    mux := http.NewServeMux()

    // Регистрация маршрутов
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "Home Page")
    })

    mux.HandleFunc("/about", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintln(w, "About Page")
    })

    // Используем ServeMux для маршрутизации
    http.ListenAndServe(":8080", mux)
}
```

#### 4\. **Middleware (обёртка над** `http.Handler`)

Можно использовать middleware, которые добавляют дополнительную логику вокруг основного обработчика. Например, логирование запросов:

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// Middleware для логирования запросов
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r) // Вызов основного обработчика
        log.Printf("Request: %s %s, Duration: %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func hello(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintf(w, "hello\n")
}

func main() {
    mux := http.NewServeMux()

    mux.HandleFunc("/hello", hello)
    })

    // Применяем middleware
    loggedMux := loggingMiddleware(mux)

    http.ListenAndServe(":8080", loggedMux)
}
```

Здесь middleware `loggingMiddleware` оборачивает основной маршрутизатор `mux` и добавляет логирование каждого запроса.