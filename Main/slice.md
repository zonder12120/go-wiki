---
order: 4
title: Slice
---

Срезы - это мощная надстройка над массивами.

Почему срезы названы именно так? Ниже я напишу почему.

Почему :)))))

Срез состоит из:

{% table %}

---

*  {% colwidth=[179] %}

   **array** unsafe.Pointer

*  {% colwidth=[379] %}

   указатель на начало выделенной памяти

---

*  {% colwidth=[179] %}

   **len** int

*  {% colwidth=[379] %}

   длина слайса

---

*  {% colwidth=[179] %}

   **cap** int

*  {% colwidth=[379] %}

   ёмоксть слайса

{% /table %}

То есть сам срез в себе  не хранит его содержимое, а его размер зависит от разрядности системы. Если ОС имеет разрядность 64 бита, то **array, len** и **cap** занимают в памяти по 8 байт, а слайс в сумме весит **24 байта**, если разрядность 32 бита, то, очевидно, слайс будет весить **12 байт.**

**Но слайс базируется на массиве!**

То есть, так как сам слайс не хранит в себе данные, он берёт данные на основе какого-то массива.

**Array** указывает на N-ый элемент базового массива. Причём массив может быть как существующим, так и создаваться при инициализации среза.

В первом случае это будет выглядеть примерно так:

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

fmt.Println(slc) // [2 3 4]
```

А чтобы стало понятнее, изобразим границы массива фигурными скобками, а среза - квадратными:

*{1,* **\[2, 3, 4\]**, *5}*

То есть обрезается какая-то часть массива по интервалу, создаётся своего рода **срез** массива.

При этом требуется также обратить внимание на то, что интервал является **полуоткрытым,** то есть мы объявили срез так: `slc := arr[1:4]`, указав индекс 1 и 4, но индекс 1 в интервал вошёл, а индекс 4 - нет. То есть начальный индекс в полуоткрытый интервал входит, а конечный - нет.

В этом случае у среза `slc` структура следующая:

{% table %}

---

*  {% colwidth=[124] isHeader=true %}

   слайс slc

*  {% colwidth=[114] isHeader=true %}

   Значение

---

*  {% colwidth=[124] %}

   **array**

*  {% colwidth=[114] %}

   &arr\[1\]

---

*  {% colwidth=[124] %}

   **len**

*  {% colwidth=[114] %}

   3

---

*  {% colwidth=[124] %}

   **cap**

*  {% colwidth=[114] %}

   4

{% /table %}

Емкость слайса `slc` равна **4**, потому что это максимальное количество элементов, которое можно вместить в слайс, начиная с его первого элемента `arr[1]`.

Вставка значений производится функцией `append(slice, value)`

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Println(slc) // [2 3 4 33]
fmt.Println(arr) // [1 2 3 4 33]
```

Как стало понятно из кода выше, при вставке в слайс нового значения, значение элемента базового массива, который стоял на этом месте, перезаписывается, а **len** слайса увеличивается на 1.

:::note 

**Кстати, можно делать срез на основе среза.**

Например:

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4] // [2 3 4]
slc1 := slc[0:2] // [2 3]
```

В таком случае все они будут базироваться на одном и том же массиве, изменения в котором отразятся на обоих слайсах

:::

Так же мы можем заметить, что подошли к конечному значению базового массива. Что будет, если мы добавим ещё один элемент, ведь у нашего слайса `slc` теперь и **len** = **cap** = 4?

А тогда у нас просто создаётся новый базовый массив и  **array** теперь будет в себе хранить ссылку на нулевой элемент этого нового массива.

Кстати, в таком случае  изменения слайса с новым базовым массивом не будут затрагивать старый базовый массив, логично, не так ли?

:::note 

**Можно не указывать границы интервала явно** при создании слайса на основе уже существующего массива, в таком случае будут браться пограничные значение **включительно,** например:

```Go
arr := [5]int{1, 2, 3, 4, 5}

slc1 := arr[:2] // [1 2]
slc2 := arr[2:] // [3 4 5]
slc3 := arr[:] // [1 2 3 4 5]
```

:::

При этом новый базовый массив вдвое больше длины слайса до добавления элемента (расширения), вот пример:

```Go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Printf("len: %d, cap: %d", len(slc), cap(slc)) // len = 4, cap = 4

slc = append(slc, 44) 

fmt.Printf("len: %d, cap: %d", len(slc), cap(slc)) // len = 5, cap = 8

fmt.Println(slc) // [2 3 4 33 44]

// Новый базовый массив = {2, 3, 4, 33, 44, 0, 0, 0}

fmt.Printf(arr) // [1, 2, 3, 4, 33]
```

Можно заметить, что в базовом массиве добавленные элементы **инициализируются нулевыми значениями** типа массива.

*Тут небольшая ремарка, вдвое слайс будет увеличиваться до какого-то предела, дальше коэффициент уменьшается, зависит от реализации компилятора, подробнее в исходном коде компилятора, но это уже для нас не имеет значения.*

При таком расширении слайса, в случае, если **старый базовый массив** больше не используется, он **удаляется сборщиком мусора**.

Это удобно, позволяет экономить память, **но тут кроется опасность.**

Если заранее не выделить достаточно памяти для слайса и часто в него что-то добавлять, то он будет расширяться большое количество раз, что может заставить создавать новые массивы чаще и работать сборщик мусора довольно много, **увеличивая нагрузку на память и процессор**.

А как нам заранее аллоцировать память для слайса?

**Есть ещё метод объявления слайса - функция make():**

```Go
slc := make([]int, 100)
```

Таким образом мы создали слайс с размером 100 и ёмкостью 100

```Go
slc := make([]int, 10, 100)
```

А так мы уже создали слайс длиной 10 и ёмкостью 100

В чём разница? Сначала можно подумать, что и так, и так создаётся базовый массив со 100 штуками нулей, **но это не так**

**Тут важная разница**, во втором случае у нас резервируется память, которая необходима для хранения 100 элементов типа int, **но инициализируются только первые 10**, остальные элементы **неинициализированы**, что означает, что они будут содержать мусорные значения, оставшиеся от предыдущего использования памяти.

Основное преимущество здесь в **экономии вычислительных ресурсов и времени**, поскольку нет необходимости перезаписывать весь массив до его полной длины.

Ещё одним заблуждением является, что  слайс нулевой ёмкости и длины будет равен **nil**

```Go
slc1 := make([]int, 0)
var slc2 []int

fmt.Println(slc1 == nil, slc2 == nil) // false, true
```

Но если мы выведем  значение `slc2`, мы получим просто пустой слайс `[]`, как и для `slc1`, а не **nil,** что может запутать.

:::danger 

**Сравнивать слайсы между собой в Go напрямую нельзя!**

Хочу напомнить, что слайс в Go представляет собой структуру, состоящую из указателя на базовый массив, длины и ёмкости. 

Сравнивать слайсы напрямую означало бы сравнивать эти три поля, что не является желаемым поведением, так как два слайса могут ссылаться на один и тот же базовый массив, но иметь разные длину и ёмкость.

Да и сравнение слайсов по указателю, длине и ёмкости не является интуитивно понятным поведением, а сравнение всех элементов слайсов было бы дорогостоющей операцией.

**Поэтому сравнивать слайсы между собой в Go напрямую нельзя**, их можно сравнивать только с **nil.**

При этом никто не запрещает сравнивать элементы через итерацию самостоятельно.

:::

Более того, `slc2`, хоть и равен **nil**, но как я уже говорил в начале, **будет так же весить 24 байта**, так как его структура не поменяется, поменяются только значения:

{% table %}

---

*  {% colwidth=[196] isHeader=true %}

   слайс slc

*  {% colwidth=[648] isHeader=true %}

   Значение

---

*  {% colwidth=[196] %}

   **array** unsafe.Pointer

*  {% colwidth=[648] %}

   nil

---

*  {% colwidth=[196] %}

   **len** int

*  {% colwidth=[648] %}

   0

---

*  {% colwidth=[196] %}

   **cap** int

*  {% colwidth=[648] %}

   0

{% /table %}

### **Работа со** слайсами

Выше мы уже разобрали работу функции `append()`. Есть ещё пару функций, которые используются при работе со слайсами

-  `copy(dst, src)`

-  `cap()`

-  `len()`

Примеры:

### Copy()

```Go
slc1 := make([]int, 5, 100)

slc2 := []int{1, 2, 3, 4, 5, 6}

slc3 := make([]int, 3)

slc4 := []int{7, 7 ,7, 7}

copy(slc1, slc2) // копируем в слайс slc1 элементы slc2

copy(slc2, slc3)

num := copy(slc3, slc4)

fmt.Println(slc1, slc2, num) // [1 2 3 4 5] [0 0 0 4 5 6] 3
```

Как видно из нашего примера, при копировании элементов одного слайса в другой, они вставляютя в начало целевого слайса, **ограничиваясь размером целевого слайса.**

Это хорошо видно по переменной `num`, при присваивании значения функции `copy()` какой-то переменной, записывается количество скопированных элементов, и не смотря на то, что в `slc4` у нас хранится 4 элемента, скопировалось всего 3, так как длина целевого слайса всего 3

Даже если ёмкость слайса больше длины копируемого слайса, мы ограничиваемся именно длиной целевого слайса!

А при копировании слайса с длиной меньше целевого, заменяются элементы в интервале от 0 до последнего элемента копируемого слайса.

### len() и cap()

```
slc := make([]int, 5, 100)

len(slc) // 5

cap(sic) // 100
```

### Многомерные слайсы

В Go можно создавать многомерные слайсы:

```
twoDSlice := [][]int{
						{1, 2, 3, 4, 5},      // Первая строка
						{6, 7, 8, 9, 10},     // Вторая строка
				    }

threeDSlice := [][][]int{
    {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
    },
    {
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20},
    },
}
```

### Лишний аргумент?

А, чуть не забыл про фичу, которой никто обычно не пользуется, но она меня в покое не оставила.

Ты мог видеть такую любопытную запись `slice := arr[1:5:6]`

Да, можно передавать в интервал среза 3 аргумента, вот пример:

```
arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

slice := arr[1:5]

fmt.Println(slice, len(slice), cap(slice)) // [2 3 4 5] 4 9

slice = arr[1:5:6]

fmt.Println(slice, len(slice), cap(slice)) // [2 3 4 5] 4 5
```

В официальной документашке об этом я инфы не нашёл, а на ютубах меня обманул паренёк, назвав третий аргумент ***ёмкостью***.

Но если ты внимательно прочитал код, то понял, что это нифига не ёмкость, так как в таком случае `cap(slice)` нам бы выдал **6**, а не **5**

Это индекс элемента, который не включительно помещает все элементы до него в базовый массив, **явно задавая нам  ёмкость**.

Ну а если границу ёмкости мы не указываем (как обычно), то ёмкость будет равна len(arr) - (len(arr) - len(slice)), ну или проще говоря: от начала слайса до конца массива.

Можно подумать, что, в первом случае мы получили базовый массив {2, 3, 4, 5, 6, 7, 8, 9, 10}

А во втором случае мы в теории получили базовый массив {2, 3, 4, 5, 6}, а значит создали новый массив, и при изменении слайса, старый базовый массив меняться не будет. **Но это не так**.

Мы так же ссылаемся на тот же самый базовый массив, просто для слайса явно задана ёмкость, которую можно так же расширить, как и в обычном слайсе, сначала опираясь на базовый массив, затем, выйдя за его рамки, создавая новый и так далее, как описано в начале этой статьи.

В целом функционал понятен, но не могу придумать кейсы для использования, так как к экономии памяти это не приводит (массив и так занимает всю свою длину).