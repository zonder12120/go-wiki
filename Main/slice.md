---
order: 4
title: Slice
---

Срезы - это мощная надстройка над массивами.

Почему срезы названы именно так? Ниже я напишу почему.

Почему :)))))

Срез состоит из:

{% table header="row" %}

---

*  {% colwidth=[179] %}

   **array** unsafe.Pointer

*  {% colwidth=[379] %}

   указатель на начало выделенной памяти

---

*  {% colwidth=[179] %}

   **len** int

*  {% colwidth=[379] %}

   длина слайса

---

*  {% colwidth=[179] %}

   **cap** int

*  {% colwidth=[379] %}

   ёмоксть слайса

{% /table %}

То есть сам срез в себе  не хранит его содержимое, а его размер зависит от разрядности системы. Если ОС имеет разрядность 64 бита, то **array, len** и **cap** занимают в памяти по 8 байт, а слайс в сумме весит **24 байта**, если разрядность 32 бита, то, очевидно, слайс будет весить **12 байт.**

**Но слайс базируется на массиве!**

То есть, так как сам слайс не хранит в себе данные, он берёт данные на основе какого-то массива.

**Array** указывает на N-ый элемент базового массива. Причём массив может быть как существующим, так и создаваться при инициализации среза.

В первом случае это будет выглядеть примерно так:

```go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

fmt.Println(slc) // [2 3 4]
```

А чтобы стало понятнее, изобразим границы массива фигурными скобками, а среза - квадратными:

*\{1,* **\[2, 3, 4\]**, *5}*

То есть обрезается какая-то часть массива по интервалу, создаётся своего рода **срез** массива.

При этом требуется также обратить внимание на то, что интервал является **полуоткрытым,** то есть мы объявили срез так: `slc := arr[1:4]`, указав индекс 1 и 4, но индекс 1 в интервал вошёл, а индекс 4 - нет. То есть начальный индекс в полуоткрытый интервал входит, а конечный - нет.

В этом случае у среза `slc` структура следующая:

```go
type slice struct {
    array unsafe.Pointer  // указатель на массив, в котором хранятся данные слайса
    len   int			  // текущая длина слайса (количество элементов)
    cap   int			  // ёмкость слайса (максимальное количество элементов без реаллокации)
}
```

Емкость слайса `slc` равна **4**, потому что это максимальное количество элементов, которое можно вместить в слайс, начиная с его первого элемента `arr[1]`.

Вставка значений производится функцией `append(slice, value)`

```go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Println(slc) // [2 3 4 33]
fmt.Println(arr) // [1 2 3 4 33]
```

Как стало понятно из кода выше, при вставке в слайс нового значения, значение элемента базового массива, который стоял на этом месте, перезаписывается, а **len** слайса увеличивается на 1.

:::info 

**Кстати, можно делать срез на основе среза.**

Например:

```go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4] // [2 3 4]
slc1 := slc[0:2] // [2 3]
```

В таком случае все они будут базироваться на одном и том же массиве, изменения в котором отразятся на обоих слайсах

:::

Так же мы можем заметить, что подошли к конечному значению базового массива. Что будет, если мы добавим ещё один элемент, ведь у нашего слайса `slc` теперь и **len** = **cap** = 4?

А тогда у нас просто создаётся новый базовый массив и  **array** теперь будет в себе хранить ссылку на нулевой элемент этого нового массива.

Кстати, в таком случае  изменения слайса с новым базовым массивом не будут затрагивать старый базовый массив, логично, не так ли?

:::info 

**Можно не указывать границы интервала явно** при создании слайса на основе уже существующего массива, в таком случае будут браться пограничные значение **включительно,** например:

```go
arr := [5]int{1, 2, 3, 4, 5}

slc1 := arr[:2] // [1 2]
slc2 := arr[2:] // [3 4 5]
slc3 := arr[:] // [1 2 3 4 5]
```

:::

При этом новый базовый массив вдвое больше длины слайса до добавления элемента (расширения), вот пример:

```go
arr := [5]int{1, 2, 3, 4, 5}
slc := arr[1:4]

slc = append(slc, 33)

fmt.Printf("len: %d, cap: %d", len(slc), cap(slc)) // len = 4, cap = 4

slc = append(slc, 44) 

fmt.Printf("len: %d, cap: %d", len(slc), cap(slc)) // len = 5, cap = 8

fmt.Println(slc) // [2 3 4 33 44]

// Новый базовый массив = {2, 3, 4, 33, 44, 0, 0, 0}

fmt.Printf(arr) // [1, 2, 3, 4, 33]
```

Можно заметить, что в базовом массиве добавленные элементы **инициализируются нулевыми значениями** типа массива.

*Тут небольшая ремарка, вдвое слайс будет увеличиваться до какого-то предела, дальше коэффициент уменьшается, зависит от реализации компилятора, подробнее в исходном коде компилятора, но это уже для нас не имеет значения.*

При таком расширении слайса, в случае, если **старый базовый массив** больше не используется, он **удаляется сборщиком мусора**.

Это удобно, позволяет экономить память, **но тут кроется опасность.**

Если заранее не выделить достаточно памяти для слайса и часто в него что-то добавлять, то он будет расширяться большое количество раз, что может заставить создавать новые массивы чаще и работать сборщик мусора довольно много, **увеличивая нагрузку на память и процессор**.

А как нам заранее аллоцировать память для слайса?

**Есть ещё метод объявления слайса - функция make():**

```go
slc := make([]int, 100)
```

Таким образом мы создали слайс с размером 100 и ёмкостью 100

```go
slc := make([]int, 10, 100)
```

А так мы уже создали слайс длиной 10 и ёмкостью 100

В чём разница? Сначала можно подумать, что и так, и так создаётся базовый массив со 100 штуками нулей, **но это не так**

**Тут важная разница**, во втором случае у нас резервируется память, которая необходима для хранения 100 элементов типа int, **но инициализируются только первые 10**, остальные элементы **неинициализированы**, что означает, что они будут содержать мусорные значения, оставшиеся от предыдущего использования памяти.

Основное преимущество здесь в **экономии вычислительных ресурсов и времени**, поскольку нет необходимости перезаписывать весь массив до его полной длины.

Ещё одним заблуждением является, что  слайс нулевой ёмкости и длины будет равен **nil**

```go
slc1 := make([]int, 0)
var slc2 []int

fmt.Println(slc1 == nil, slc2 == nil) // false, true
```

Но если мы выведем  значение `slc2`, мы получим просто пустой слайс `[]`, как и для `slc1`, а не **nil,** что может запутать.

Объясняется такое поведение тем, что когда мы создаём слайса так: `slc1 := make([]int, 0)`, то его длина и ёмкость равны нулю, но указатель на базовый массив не равен `nil`, а будет указывать на пустую область памяти.

А когда мы создаём слайс таким образом `var slc2 []int`, то и длина, и ёмкость равны нулю + указатель на базовый массив равен `nil`

Более того, `slc2`, хоть и равен **nil**, но как я уже говорил в начале, **будет так же весить 24 байта**, так как его структура не поменяется, поменяются только значения:

{% table header="row" %}

---

*  {% colwidth=[196] %}

   слайс slc

*  {% colwidth=[648] %}

   Значение

---

*  {% colwidth=[196] %}

   **array** unsafe.Pointer

*  {% colwidth=[648] %}

   nil

---

*  {% colwidth=[196] %}

   **len** int

*  {% colwidth=[648] %}

   0

---

*  {% colwidth=[196] %}

   **cap** int

*  {% colwidth=[648] %}

   0

{% /table %}

:::danger 

**Сравнивать слайсы между собой в Go напрямую нельзя!**

Слайс в Go представляет собой структуру, состоящую из указателя на базовый массив, длины и ёмкости.

Сравнивать слайсы напрямую означало бы сравнивать эти три поля, что не является желаемым поведением, так как два слайса могут ссылаться на один и тот же базовый массив, но иметь разные длину и ёмкость.

Да и сравнение слайсов по указателю, длине и ёмкости не является интуитивно понятным поведением, так как ожидается сравнение по элементам, а сравнение всех элементов слайсов было бы дорогостоющей операцией.

**Поэтому сравнивать слайсы между собой в Go напрямую нельзя**, их можно сравнивать только с **nil.**

При этом никто не запрещает создать функцию сравнения  элементов слайсов через итерацию :)

:::

### **Работа со** слайсами

Выше мы уже разобрали работу функции `append()`. Есть ещё пару функций, которые используются при работе со слайсами

-  `copy(dst, src)`

-  `cap()`

-  `len()`

Примеры:

### Copy()

```go
slc1 := make([]int, 5, 100) // [0 0 0 0 0]

slc2 := []int{1, 2, 3, 4, 5, 6} // [1 2 3 4 5 6]

slc3 := make([]int, 3) // [0 0 0]

slc4 := []int{7, 7 ,7, 7} // [7 7 7 7]

copy(slc1, slc2) // копируем в слайс slc1 элементы slc2

copy(slc2, slc3) // копируем в слайс slc2 элементы slc3

num := copy(slc3, slc4) // копируем в слайс slc3 элементы slc4

fmt.Println(slc1, slc2, num) // [1 2 3 4 5] [0 0 0 4 5 6] 3
```

Как видно из нашего примера, при копировании элементов одного слайса в другой, они вставляютя в начало целевого слайса, **ограничиваясь размером целевого слайса.**

Это хорошо видно по переменной `num`, при присваивании значения функции `copy()` какой-то переменной, этой переменной записывается количество скопированных элементов, и не смотря на то, что в `slc4` у нас хранится 4 элемента, скопировалось всего 3, так как длина целевого слайса всего 3 (`slc3 := make([]int, 3)`)

Даже если ёмкость целевого слайса больше длины копируемого слайса, мы ограничиваемся именно **длиной (len)** целевого слайса!

А при копировании слайса с длиной меньше целевого, заменяются элементы в интервале от 0 до последнего элемента копируемого слайса.

### len() и cap()

```
slc := make([]int, 5, 100)

len(slc) // 5

cap(sic) // 100
```

### Многомерные слайсы

В Go можно создавать многомерные слайсы:

```go
twoDSlice := [][]int{
						{1, 2, 3, 4, 5},      // Первая строка
						{6, 7, 8, 9, 10},     // Вторая строка
				    }

threeDSlice := [][][]int{
    {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
    },
    {
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20},
    },
}
```

### Лишний аргумент?

А, чуть не забыл про фичу, которой редко пользуются при веб разработке, но она меня в покое не оставила.

Ты мог видеть такую любопытную запись типа `slice := arr[1:5:6]`

Да, можно передавать в интервал среза 3 аргумента, вот пример:

```go
arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

slice := arr[1:5]

fmt.Println(slice, len(slice), cap(slice)) // [2 3 4 5] 4 9

slice = arr[1:5:6]

fmt.Println(slice, len(slice), cap(slice)) // [2 3 4 5] 4 5

slice = arr[:5:6]

fmt.Println(slice, len(slice), cap(slice)) // [1 2 3 4 5] 5 6
```

В официальной документашке об этом я инфы не нашёл, а на ютубах меня обманул паренёк, назвав третий аргумент ***ёмкостью***.

Но если ты внимательно прочитал код, то понял, что это нифига не ёмкость, так как в таком случае `cap(slice)` на пятой строчке нам бы выдал **6**, а не **5**

Это индекс элемента, который является по сути границей ёмкости слайса ВКЛЮЧИТЕЛЬНО, **явно задавая нам  ёмкость**, при этом начальным индексом ёмкости будет индекс, переданный первым в интервал.

Как раз это видно на последней строчке пример, где мы берём слайс от начала до 5-го элемента, а ёмкость ограничиваем на 6-м элементе.

Нужно это чтобы если у нас слишком большой массив, например длиной в 150 элементов, а нам нужно сделать на основе его слайс всего от 1 до 5 индекса, то не создавался слайс с ёмкостью в 149 элементов, опираясь на базовый массив, а чтобы мы могли явно ограничить эту ёмкость, ибо излишняя нам не особо нужна для дальнейшей работы. В таком случае сборщик мусора мог бы просто удалить «хвост» базового массива, если на тот больше не было бы нигде ссылок.

Ну а если границу ёмкости мы не указываем (как обычно), то ёмкость будет равна len(arr) - (len(arr) - len(slice)), ну или проще говоря: от начала слайса до конца массива.

Но в таком случае мы всегда будем иметь ёмкость от начала слайса до конца массива, что не позволит сборщику мусора удалить «хвост»  базового массива, захламляя нашу память.