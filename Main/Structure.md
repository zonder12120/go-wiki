---
order: 5.5
title: Структуры
---

Структуры в Go - это набор именованых полей, служащий для представления каких-либо объектов.

## Объявление структур

Объявлять структуры можно разными способами:

1. Через доступ к самим полям

   ```go
   type Human struct {
   	name string
   	age uint8
   	sex string 
   }
   
   var tom Human
   
   tom.name = "Tom"
   tom.age = 32
   tom.sex = "male"
   ```

2. Через композитные литералы

   :::note 

   **Композитный литерал** -- это запись, состоящая из типа литерала, за которым следует список значений в фигурных скобках. Он создает новый экземпляр указанного типа с инициализацией его значений.

   :::

   1. В этом варианте важно сохранять порядок полей, как они объявлены в самой структуре, важно инициализировать все поля

      ```go
      type Person struct {
      	name string
      	age uint8
      	sex string 
      }
      
      tom := Person{"Tom", 32, "male"}
      ```

   2. В этом варианте не важен порядок, не важно инициализировать поля, потому что в таком случае они изначально принимают нулевое значение типа, но важно в конце оставить висящую запятую

      ```go
      type Person struct {
      		name string
      		age uint8
      		sex string 
      	}
      
      tom := Person{
      		name: "Tom",
      		sex: "male",
      		age: 32,
      	}
      ```

3. Ну и через обычный литерал с явным объявлением

   ```go
   type Person struct {
   		name string
   		age uint8
   		sex string 
   	}
   
   var tom Person = Person{   // Можно указывать тип после имени переменной, можно не указывать
   		name: "Tom",
   		sex:  "male",
   		age:  32,
   	}
   ```

## Особенности

:::note 

**Структуры не являются ссылочным типом**, поэтому также как и массивы **передаются по значению**.

Поэтому, при передаче экземпляра структуры в функцию, если нам нужно изменять оригинал экземпляра, нам нужно передавать его по указателю.

:::

В Go **нет ключевых слов для модификаторов доступа** для переменных, зато есть ЗАГЛАВНЫЕ БУКВЫ!!!11!!

```go
type Person struct {
    Name string  // Публичное поле
    sex  int     // Приватное поле
}
```

Заглавные буквы являются аналогом модификатора доступа **public**, справедливо для всех типов данных. Например, структура Person, описанная выше, тоже является публичной, а занчит мы можем её использовать из другого пакета.

Для структур можно определять методы, но об этом в следующей статье “ООП в Go”, так как методы касаются не только структур

## Конструктор (создание экземпляра структуры)

Общепринятой лучшей практикой в Go является использование указателя на структуру при создании экземпляра. Более того, принято реализовывать конструкторы для создания экземпляра структуры. Встроенного конструктора нет, нужно создавать для каждой структуры функцию, которая будет возвращать указатель на экземпляр структуры.

Пример:

```go
type Person struct {
	Name    string
	Age     uint8
	FavSong string
}

//Метод-конструктор, возвращающий экземпляр структуры. Принято обзывать "New + название структуры"
func NewPerson(name string, age uint8, favSong string) *Person {
	return &Person{
		Name:    name,
		Age:     age,
		FavSong: favSong,
	}
}

func main() {
	hughie := NewPerson("Hughie", 32, "Billy Joel - Pressure")
}
```

НО есть исключение, когда лучше всё-таки не использовать указатель на структуру, а передавать её по значению, об этом ниже.

## Выравнивание структур

На эту тему (и не только) есть клёвая статья: <https://habr.com/ru/companies/vk/articles/776766/>

Смысл в том, что во время компиляции происходит внутренняя оптимизация структур.

Напоминаю, что процессор может за такт обработать одно машинное слово, что в современных 64 битных процессорах - 8 байт.

Объявим структуру:

```go
type employee struct {
		married bool
		name    string
		age     uint8
	}
```

Возможно, ты подумаешь, что в памяти это расположтится таким образом:

![](./Structure-2.png)

Но такое расположение в памяти не эффективно, так как процессор будет обрабатывать данные по слову, что заставит данные переменной `name` разделиться на 3 куска разной длины, которые надо будет как-то ещё и собирать, а процессор ещё и считает переменную name не за 2 такта, а за 3. Не дело.

Поэтому Go делает struct padding (структурное выравнивание):

![](./Structure.png)

То есть байты заполняются нулями, чтобы информация была записана наиболее равномерно относительно размерности машинного слова.

Уже лучше, но вся структура у нас теперь читается за 4 такта + байты заполнились, а значит вес у нас 32 байта, из которых 14 - лишние, а это конские 43.75%. Представил громадные структуры?

**Поэтому перепишем структуру в порядке убывания полей:**

```go
type employee struct {
		name    string
		age     uint8
		married bool
	}
```

Тогда в памяти у нас будет такая картина

![](./Structure-3.png)

Уже всего 3 машинных слова, 24 байта, лишние из которых только 6 (всего 25%)

**Cтоит себе взять в привычку располагать поля в порядке убывания полей**, если структура будет довольно крупной. Если небольшая структурка, которая не будет копироваться много раз, то ~~зачем она вообще~~ можно больше опираться на читаемость кода.

## Структурные теги (JSON, XML)

Теги в структурах Go используются для того, чтобы дать дополнительные инструкции для сериализации и десериализации данных, таких как JSON, XML, Protobuf и других форматов.

Применения:

1. **Переименование полей**: Поля структуры могут иметь имена, отличные от тех, что используются в формате данных.

2. **Пропуск полей**: Некоторые поля могут быть исключены из сериализации или десериализации.

3. **Специальные инструкции по обработке полей**: Теги могут передавать специфичные команды для кодировщиков/декодировщиков.

Структурные теги Go представляют собой аннотации, которые появляются в объявлении структуры Go после типа. Каждый тег состоит из коротких строк, связанных с некоторым соответствующим значением. То есть пары ключ-значение.

Вот как выглядит код сериализации и десериализации для JSON:

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Person struct {
	Name string `json:"full_name"` // Здесь мы задаём другое имя для JSON
	Age  int    `json:"age"`	   // И здесь тоже, потому что регистр другой
}

func main() {
	p := Person{Name: "Alice", Age: 30}

	jsonData, err := json.Marshal(p)
	if err != nil {
		fmt.Printf("Error marshaling struct to JSON: %v\n", err)
		return
	}

	fmt.Println(string(jsonData)) // {"full_name":"Alice","age":30}

	err = json.Unmarshal(jsonData, &p) // Записываем в экземпляр структуры Person данные из JSON
	if err != nil {
		fmt.Printf("Error unmarshaling JSON to struct: %v\n", err)
		return
	}

	fmt.Println(p) // {Alice 30}
}
```

Мы подключили пакет **json** из каталога **encoding**, а затем использовали функции **Marshal()** и Unmarshal() для сериализации и десериализации соответственно.

:::note 

**При отсутсвии тегов названия полей в JSON соответствовали бы названию полей структуры.**

То есть была бы JSON’ка вот такого вида: \{“Name”:”Alice”, «Age»:30}

:::

Ещё с помощью тегов можно задавать поведение полей при сериализации:

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name  string `json:"name"`
    Age   int    `json:"age"`
    Email string `json:"-"`     // Пропускаем поле Email
}

func main() {
    p := Person{Name: "Alice", Age: 30, Email: "alice@example.com"}

    jsonData, err := json.Marshal(p)
	if err != nil {
		fmt.Printf("Error marshaling struct to JSON: %v\n", err)
		return
	}

    fmt.Println(string(jsonData))  // {"name":"Alice","age":30}
}
```

А можно сделать поле опциональным, например:

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name  string `json:"name"`
    Age   int    `json:"age,omitempty"`
    Email string `json:"email,omitempty»` // Пропускаем поле, если нулевое значение 
}

func main() {
    p := Person{Name: "Alice", Age: 0, Email: ""}

    jsonData, err := json.Marshal(p)
	if err != nil {
		fmt.Printf("Error marshaling struct to JSON: %v\n", err)
		return
	}

    fmt.Println(string(jsonData))  // {"name":"Alice"}
}
```

Можно задать явно тип полю, например если поле является числом, обычно оно сериализуется как число, но нам надо как строку:

```go
type Person struct {
	Name string `json:"full_name"`
	Age  int    `json:"age,string,omitempty,»` // Делаем строкой, пропускаем, если 0
}

func main() {
	p := Person{Name: "Alice", Age: 30}

	jsonData, err := json.Marshal(p)
	if err != nil {
		fmt.Printf("Error marshaling struct to JSON: %v\n", err)
		return
	}

	fmt.Println(string(jsonData)) // {"full_name":"Alice","age":"30"} 
}
```

## Передача структуры по значению или по указателю?

:::lab 

Выше уже описаны общепринятые практики, но всё же есть спорные моменты, хочу дать полную информацию, которую смог добыть.

Да и от проекта к проекту люди могут навязывать свои стандарты, поэтому важно знать, что и когда лучше всего использовать, чтобы навязать свои))))

:::

Первое, что приходит на ум - мьютексы, которые нельзя копировать, т.е. передавать структуры с ними по значению нельзя, можно только через указатель.

А ещё передавать структуры по указателю удобно, когда нужно обрабатывать ошибку и возвращать err и значение, в таком случае мы можем просто вернуть err и nil, что куда корректнее выглядит, чем err и, допустим, 0. И в месте, где эта функция используется, придётся проверять не на nil, а на 0. А если мы захотим использовать не int, а, внезапно, строку?

Когда мы передаём структуру по значению, мы создаём копию, что, разумеется, создаёт некоторые накладные расходы на память. Но важно понимать, **когда использовать указатели, а когда - оно того не стоит.**

Из раздела “База”, статьи про процессора, мы знаем, что кэш делится на кэш-линии, длиной по 64 байта (в случае большинства современных процессоров).

И обычно принято ориентироваться на то, что если структура весит \<= 64 байт, то нет смысла использовать указатели для передачи структуры, процесс копирования и так будет очень быстрым.

А лишний раз использовать указатели = захламлять кучу = напрягать garbage collector, который достаточно дорогой в Go.

:::info 

1. В Go сборщик мусора может стать узким местом в производительности, особенно при активном создании и удалении объектов в куче.

2. Избыточное использование указателей может увеличить нагрузку на сборщик мусора, что приведет к снижению производительности.

:::

А вот если структура > 64 байт…

Да в целом это холивар, здесь все по-своему на это смотрят: <https://habr.com/ru/companies/it-guide/articles/744046/>

Обычно принято в конструкторе возвращать указатель на структуру.

Но не смотря на то, что принято, иногда это будет не верным решением, особенно в небольшом специфичном функционале, так что вот тебе немного слов ЗА и ПРОТИВ на случай, когда есть спорный момент:

-  Если метод **не должен изменять структуру** (например, он только читает данные), можно передавать структуру **по значению**. Это помогает защитить данные от нежелательных изменений.

-  Передача структур по значению в метод или переменную может упростить код, избегая проверок на nil.

:::note 

**Каждый раз, когда ты работаешь с указателем, тебе нужно проверять, не равен ли он nil**. Пропуск такой проверки может привести к панике (runtime panic) при попытке доступа к полям структуры через nil-указатель.

:::

#### **Можно ориентироваться на следующее**:

-  Для структур размером до 2-3 кэш-линий (т.е. до 128-192 байт) передача по значению обычно приемлема.

-  Для структур размером больше 3 кэш-линий (более 192 байт) предпочтительнее передавать по указателю.

#### Примерные размеры

-  **Маленькие структуры** (до 64 байт): могут включать несколько примитивных полей, таких как `int`, `float64`, `bool`, и могут быть переданы по значению без значительных накладных расходов.

-  **Средние структуры** (64-192 байт): структуры, включающие несколько массивов или строк, и могут быть переданы по значению в зависимости от контекста и использования.

-  **Большие структуры** (более 192 байт): структуры, содержащие большие массивы, срезы или множество полей, чаще передаются по указателю для улучшения производительности.

#### **Консистентность**

Важно придерживаться единого стиля на протяжении всего проекта. Если принято во всём проекте передавать структуру по указателю, то необходимо придерживаться этого решения, учитывая все накладные расходы при разработке (например, проверки на nil).