---
order: 6.5
title: "Интерфейсный \_тип"
---

## Как устроены интерфейсы внутри?

В разделе про ООП мы разобрали что такое интерфейсы и зачем они нужны.

Но как интерфейс работает под капотом?

Это достаточно частый вопрос на собесах, так что бери на вооружение.

**Не пустой интерфейс (с методами):**

```go
type iface struct {
    tab  *itab          // Указатель на таблицу методов (vtable): содержит информацию о типе и методах для интерфейсного вызова
    data unsafe.Pointer // Указатель на данные, реализующие интерфейс (конкретное значение)
}
```

**Пустой интерфейс (interface\{}**)

```go
type eface struct {
    _type *_type         // Указатель на тип конкретного значения
    data  unsafe.Pointer // Указатель на данные, реализующие интерфейс (конкретное значение)
}
```

Разберёмся, как заполняются поля не пустого интерфейса

### Заполнение не пустого интерфейса

Давай разберемся на конкретном примере, как создается и заполняется `itab`. Возьмем интерфейс `io.Reader` и тип `*os.File`, который его реализует.

```go
var r io.Reader      // Интерфейс
file, _ := os.Open("test.txt")
r = file             // Присваивание интерфейсу значения *os.File
```

1. Go проверяет, что `*os.File` реализует **все методы** интерфейса `io.Reader` (в данном случае -- метод `Read()`).

   -  Если методов не хватает --> **ошибка компиляции**.

   -  Если все OK --> переходит к созданию `itab`.

2. Go хранит кэш `itab`\-ов, чтобы избежать повторных вычислений. Ключ кэша -- пара `(интерфейс, тип)`.

   -  Если `itab` для `(io.Reader, *os.File)` уже есть --> используется существующий.

   -  Если нет --> создается новый.

3. **Создание нового** `itab`

```go
type itab struct {
    inter *interfacetype // io.Reader
    _type *_type         // *os.File
    hash  uint32         // Хэш типа *os.File
    fun   [1]uintptr     // Адрес метода Read()
}
```


