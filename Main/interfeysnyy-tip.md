---
order: 6.5
title: "Интерфейсный \_тип"
---

## Как устроены интерфейсы внутри?

В разделе про ООП мы разобрали что такое интерфейсы и зачем они нужны.

Но как интерфейс работает под капотом?

Это достаточно частый вопрос на собесах, так что бери на вооружение.

### **Не пустой интерфейс (с методами):**

```go
type iface struct {
    tab  *itab          // Указатель на таблицу методов (vtable): содержит информацию о типе и методах
    data unsafe.Pointer // Указатель на данные, реализующие интерфейс (конкретное значение)
}
```

### **Пустой интерфейс (interface\{}**)

```go
type eface struct {
    _type *_type         // Указатель на тип конкретного значения
    data  unsafe.Pointer // Указатель на данные, реализующие интерфейс (конкретное значение)
}
```

Разберёмся, как заполняются поля не пустого интерфейса.

## Заполнение не пустого интерфейса

Давай разберёмся на конкретном примере. Допустим, у нас есть такой код:

```go
var r io.Reader                // Интерфейсный тип
file, _ := os.Open("test.txt") // В данном случае у нас file будет типа *os.File
r = file                       // Записываем в r значение file
_ = r
```

В таком случае данный экземпляр интерфейса io.Reader будет иметь под собой структуру `iface` с полями `tab` и `data`, ниже мы посмотрим как эти поля заполнятся.

### itab

Давай разберемся на конкретном примере, как создается и заполняется `itab`. Возьмем интерфейс `io.Reader` и тип `*os.File`, который его реализует из примера выше.

1. Go проверяет, что `*os.File` реализует **все методы** интерфейса `io.Reader` (в данном случае -- метод `Read()`).

   -  Если методов не хватает --> **ошибка компиляции**.

   -  Если все OK --> переходит к созданию `itab`.

2. Go хранит кэш `itab`\-ов, чтобы избежать повторных вычислений. Ключ кэша -- пара `(интерфейс, тип)`.

   -  Если `itab` для `(io.Reader, *os.File)` уже есть --> используется существующий.

      Если ты 100 раз присвоишь `*os.File` переменной типа `io.Reader`, `itab` будет создан только один раз -- это экономит память и время.

   -  Если нет --> создается новый.

3. **Создание нового** `itab`

```go
type itab struct {
    inter *interfacetype // io.Reader
    _type *_type         // *os.File
    hash  uint32         // Хэш типа *os.File, который используется для оптимизации операций с интерфейсами, таких как type switches.
    fun   [1]uintptr     // Адрес метода Read(). Если методов больше, то и массив больше
}
```

### data

Как и сказано выше, туда записывается указатель на данные, реализующие интерфейс.

В нашем примере это `*os.File`, то есть указатель. В таком случае, если бы наш интерфейс имел бы методы, которые изменяют структуру, то оригинальная структура была бы изменена.

В интерфейс можно передавать не только указатель, но и структуру. Но в таком случае Go создаёт копию исходной структуры и записывает в поле `data` указатель на эту копию.

Например:

```go
type MyReader struct{}

func (m MyReader) Read(p []byte) (n int, err error) { return 0, nil }

m := MyReader{}       // m — структура (не указатель)
var r io.Reader = m   // Создаётся копия m, r.data указывает на неё
```

В таком случае, если бы у интерфейса были бы методы, которые изменяют структуру, исходная структура `m` не была бы изменена, изменения были бы только в переменной `r`.

## Заполнение пустого интерфейса

Например у нас есть такой код:

```go
var empty interface{}
empty = 0
```

Как заполняются в нём поля `data` и `_type`?

### \_type

Это **указатель на метаданные типа** (runtime-информацию) значения, которое хранится в интерфейсе. Это ключевой механизм, позволяющий Go работать с любыми типами в рантайме.

Поле `_type` заполняется **во время присваивания значения** пустому интерфейсу. Go автоматически определяет тип значения и записывает соответствующую runtime-информацию в `_type`.

Для **встроенных типов** (`int`, `string`, `slice` и т.д.) Go создаёт `_type`\-объекты при старте программы (они хранятся в статической памяти).

Для **пользовательских типов** (структур) `_type` генерируется во время компиляции и сохраняется в бинарном файле.

Метаданные типа включают:

1. **Категория типа** (`kind`):

   -  [`reflect.Int`](http://reflect.Int), `reflect.String`, `reflect.Struct`, `reflect.Ptr` и т.д.

   -  Полный список: [виды типов в Go](https://golang.org/pkg/reflect/#Kind).

2. **Размер типа** (`size`):

   Сколько памяти занимает значение этого типа (например, `int` -- 8 байт на 64-битной системе).

3. **Имя типа** (`name`):

   Для пользовательских типов (например, `"MyStruct"`).

4. **Дополнительные поля** в зависимости от типа:

   -  Для **структур**: список полей, их типы и оффсеты.

   -  Для **срезов/массивов**: тип элемента и длина.

   -  Для **функций**: типы аргументов и возвращаемых значений.

   -  Для **интерфейсов**: список методов.

### data

Тут аналогично не пустому интерфейсу.

## Нюансы

### nil interface trap

Если присвоить интерфейсу `nil`, `data` станет `nil`, но `tab` останется. Поэтому при проверке такого интерфейса на `nil` будет `false`.

```go
var buf *bytes.Buffer // buf == nil
var r io.Reader = buf // r.tab != nil, r.data == nil
fmt.Println(r == nil) // false
```

Но если ничего не инициализировать переменную интерфейсного типа, то интерфейс будет == nil, потому что ни в itab, ни в data не будут записаны данные

```go
var r io.Reader
fmt.Println(r == nil) // true
```

### Сравнения интерфейсов